## 메모리 관리 질문

<details>
<summary> <strong> MMU의 역할과 동작 과정에 대해 설명해주세요. </strong></summary>
<div markdown="1">

MMU는 CPU에서 논리 주소를 물리 주소로 변환하는 역할을 수행하는 하드웨어 모듈이다. 페이지 테이블을 참조하여 변환을 수행하며, TLB를 활용하여 주소 변환 속도를 높일 수 있다.

1. CPU가 가상 주소를 생성한다.
   - 프로그램이 메모리에 접근할 때, CPU는 가상 주소를 생성한다.
   - 이 가상 주소는 프로세스마다 독립적으로 관리되며 실제 물리 메모리 주소와 다를 수 있다.
2. MMU가 주소를 변환한다.(주소 매핑)
   - MMU는 가상 주소를 물리 주소로 변환한다.
   - 페이지 테이블을 참고하여 가상 주소의 페이지 번호를 물리 메모리의 프레임과 매핑한다.
   - TLB를 이용해 변환 속도를 높일 수 있다.
3. 메모리 보호 및 접근 권한을 확인한다.
   - MMU는 프로세스가 허용된 메모리 영역만 접근하도록 보호 기능을 수행한다.
   - 페이지 테이블에 저장된 접근 권한을 검사하여 잘못된 접근 시 페이지 폴트 또는 예외를 발생시킨다.
4. 변환된 물리 주소를 메모리에 전달한다.
   - MMU가 변환한 물리 주소를 메모리 컨트롤러로 전달하여 데이터를 읽거나 저장하도록 한다.
5. 캐싱 및 성능 최적화를 한다.
   - MMU는 TLB를 사용해 자주 사용되는 주소 변환 결과를 캐싱한다.
   - 캐시에 있는 변환 정보를 사용하면 속도가 빠르고, 없으면 페이지 테이블을 다시 조회한다.

<details>
<summary> <strong> TLB 관점에서, Context Switching 발생 시 어떤 변화가 발생하는지 설명해 주세요. </strong></summary>
<div markdown="1">

Context Switching이 발생하면 이전 프로세스의 주소 공간과 현재 프로세스의 주소 공간이 다르므로 TLB를 무효화해야한다. TLB Flush가 발생하면 기존의 TLB 엔트리들이 삭제되어 성능 저하가 생길 수 있다. 이를 줄이기 위해서 Address Space Identifier 같은 기법이 사용되기도 한다.

</div>
</details>

</div>
</details>

---

<details>
<summary> <strong> 내부 단편화가 무엇이고, 어떤 메모리 관리 기법에서 발생할 수 있는지 설명해주세요. </strong></summary>
<div markdown="1">

내부 단편화는 메모리 블록이 프로세스 크기보다 클 때, 사용되지 않고 남은 공간이 생기는 현상을 말한다. 페이징같은 고정 분할 방식 같은 기법에서 내부 단편화가 발생할 수 있다.

<details>
<summary> <strong> 내부 단편화를 완화하기 위한 방법에는 무엇이 있을까요? </strong></summary>
<div markdown="1">
  
- 동적 메모리 할당: 프로세스가 필요한 만큼씩 메모리를 할당하면 내부 단편화를 줄일 수 있다. 
- 페이징: 메모리를 작은 페이지 단위로 나누어 프로세스 크기에 맞게 배치한다. 내부 단편화가 거의 발생하지 않지만 페이지 크기보다 작은 단편화는 존재할 수 있다. 
- 세그멘테이션: 프로세스를 논리적인 크기로 나누어 메모리 낭비를 방지한다. 가변적인 크기의 세그먼트 할당으로 불필요한 공간 낭비를 최소화한다.

</div>
</details>

</div>
</details>

---

<details>
<summary> <strong> 캐시 메모리란 무엇일까요? </strong></summary>
<div markdown="1">

CPU와 RAM 간 속도 차이를 보완하기 위한 고속 임시 저장소를 말한다. 최근 접근한 데이터를 캐시에 저장하여 메모리 접근 속도를 향상한다.

<details>
<summary> <strong> 캐시 메모리에서 발생하는 캐시 일관성 문제는 무엇이고, 이를 해결하기 위한 방법에는 무엇이 있을까요? </strong></summary>
<div markdown="1">

멀티 코어 환경에서 각 코어는 독립적인 캐시를 가지고 있다. 이때, 한 코어에서 특정 데이터를 수정하면, 다른 캐시에 저장된 같은 데이터와 불일치가 발생할 수 있다.

데이터 변경은 메모리(RAM)에 저장된 원본 데이터가 바뀌는 것을 의미한다.
캐시는 단순히 메모리의 특정 시점을 저장하고 있을 뿐 항상 최신 데이터를 반영하는 것은 아니다. 따라서 한 캐시에서 데이터를 수정했을 때, 다른 캐시에는 여전히 이전 값이 남아 있을 수 있어 캐시 불일치가 발생한다.

- 쓰기 갱신: 데이터가 변경될 때 모든 캐시에 즉시 반영하는 방식
- 쓰기 무효화: 하나의 캐시에서 데이터가 변경되면 다른 캐시의 해당 데이터를 무효화하는 방식
- MESI 프로토콜: 현재 CPU에서 흔히 쓰이는 캐시 일관성 프로토콜

</div>
</details>

<details>
<summary> <strong> 캐시 교체 정책에 대해 아는만큼 설명해주세요. </strong></summary>
<div markdown="1">

- LRU: 가장 오래 사용되지 않은 캐시 제거
- FIFO: 가장 먼저 들어온 캐시 제거
- LFU: 사용 빈도가 낮은 캐시 제거

</div>
</details>

<details>
<summary> <strong> 프리페칭 기법은 캐시 성능 향상에 어떻게 기여할까요? </strong></summary>
<div markdown="1">

미래에 사용할 데이터를 미리 캐시에 로드해서 캐시 미스를 감소시킨다.

- 선형 프리페칭: 시간적 지역성을 활용
  - 최근 사용한 데이터는 다시 사용될 가능성이 높다.
  - 반복문에서 같은 변수를 여러 번 접근할 때, 미리 캐시에 로드하면 캐시 미스를 줄일 수 있다.
- 블록 프리페칭: 공간적 지역성을 활용
  - 인접한 메모리 주소의 데이터도 함께 사용될 가능성이 높다.
  - 배열을 순차적으로 접근할 때, 다음 번에 사용할 요소를 미리 캐시에 로드하면 성능 향상이 가능하다.
- 하드웨어 프리페칭: CPU가 자동으로 미리 데이터를 가져오는 방식
- 소프트웨어 프리페칭: 프로그래머가 명시적으로 prefetch 명령을 사용해 데이터를 미리 로드하는 방식

</div>
  </details>

</div>
</details>

---

<details>
<summary> <strong> 메모리 관리가 필요한 이유가 무엇일까요? </strong></summary>
<div markdown="1">

메모리는 한정적인 자원이므로 효율적인 관리가 필요하다.

- 프로세스 간 메모리 충돌 방지: 여러 프로그램이 동시에 실행될 때 하나의 프로세스가 다른 프로세스 메모리를 침범하지 않도록 보호한다.
- 메모리 낭비 방지: 내부/외부 단편화를 최소화하여 가용 메모리를 최대한 활용한다.
- 프로세스 실행 최적화: 필요한 데이터를 빠르게 접근할 수있도록 캐시, 가상 메모리 등을 활용하여 성능을 향상한다.

<details>
<summary> <strong> 메모리를 보호하기 위한 기법에는 무엇이 있을까요? </strong></summary>
<div markdown="1">

- 프로세스 격리: 하나의 프로세스가 다른 프로세스의 메모리에 접근하지 못하도록 한다.
- MMU 사용: 가상 주소를 물리 주소로 변환하며 접근 권한을 제어한다.
- 페이지 테이블 보호 비트: 특정 메모리 영역의 실행 여부를 제한하여 보안을 강화한다.

</div>
</details>

<details>
<summary> <strong> 컨테이너화된 환경(도커, 쿠버네티스 등)에서 메모리 관리는 어떻게 이루어지나요? </strong></summary>
<div markdown="1">

- 리소스 제한: 컨테이너의 메모리 사용량을 설정하여 과도하게 사용하지 않도록 제한한다.
- OOM Killer: 시스템이 메모리 부족 상태가 되면 메모리를 가장 많이 사용하는 프로세스를 강제 종료한다.
- 메모리 Overcommit: 리소스 공유를 통해 물리적인 메모리보다 많은 메모리를 할당 가능하다.

</div>
</details>

<details>
<summary> <strong> 최신 운영체제에서 메모리 관리 기술 트렌드는 무엇인가요? </strong></summary>
<div markdown="1">

- Zero Copy 기술: 데이터를 복사하지 않고 직접 전달하여 성능을 향상한다.
- Persistent Memory: RAM과 SSD의 중간 단계로 전원이 꺼져도 데이터가 유지되는 메모리

</div>
</details>

</div>
</details>
