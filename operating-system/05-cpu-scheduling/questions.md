## CPU 스케쥴링 질문

<details>
<summary> <strong> 멀티태스킹 환경에서 CPU 스케줄링의 역할과 목표에 대해 설명해주세요. </strong></summary>
<div markdown="1">

멀티태스킹 환경에서는 여러 프로세스가 동시에 실행되는 것처럼 보이지만 실제로는 CPU가 프로세스 간을 빠르게 전환하면서 실행한다. CPU 스케줄링은 CPU 사용을 최적화하여 시스템 성능을 향상한다. 그리고 여러 프로세스가 공정하게 CPU를 할당받도록 조정한다.

CPU 스케쥴링의 목표는 CPU 이용률을 극대화하고 처리량을 향상하는데에 있다. 또한 대기시간과 응답 시간을 최소화한다. 그리고 공정성을 조정하여 특정 프로세스가 지나치게 많은 자원을 차지하지 않도록 조정한다.

<details>
<summary><strong> CPU 스케줄링에서 선점형과 비선점형 스케줄링 방식의 차이를 설명하고, 실시간 시스템에서는 어떤 방식이 더 적합한지 설명해주세요. </strong></summary>
<div markdown="1">

선점형 스케쥴링이란 CPU를 사용하고 있는 프로세스 혹은 스레드를 다른 프로세스나 스레드가 중간에 빼앗을 수 있는 것이고, 비선점형은 빼앗지 못하고 완전히 종료될때까지 CPU를 유지하는 것을 말한다.

실시간 시스템에서는 작업이 정해진 시간 내에 반드시 끝나야 하는 경우가 많기 떄문에 CPU를 중간에 빼앗는 선점형 스케줄링보다는 비선점형 스케줄링이 적합하다.

</div>
</details>

<details>
<summary><strong> FCFS와 라운드로빈의 차이를 설명해주세요 </strong></summary>
<div markdown="1">

FCFS는 먼저 들어온 순서대로 처리를 하는 것이고 라운드로빈은 일정한 시간마다 프로세스를 교체하는 방법이다. FCFS는 긴 작업이 먼저 오면 뒤 프로세스가 오래동안 기다려야할 수 있어서 공정하지 않을 수 있고, 초기 응답이 느릴 수 있다. 반면 라운드로빈의 경우 일정시간이 경과되면 다음 프로세스로 교체되기 때문에 모든 프로세스가 공평하게 CPU를 사용할 수 있으며 응답 시간이 빠르다. 하지만 라운드로빈의 기준 시간이 너무 짧으면 컨텍스트 스위칭이 많이 일어나 오버헤드가 커질 수 있고 너무 길면 FCFS와 비슷해진다.

</div>
</details>

</div>
</details>

---

<details>
<summary><strong> CPU 스케줄링에서 FCFS에서 발생하는 convoy effect는 어떤 현상인가요? </strong></summary>
<div markdown="1">

CPU 버스트 시간이 긴 프로세스가 먼저 실행되면 뒤에 있는 짧은 프로세스들이 오랫동안 기다려야하는 문제가 발생한다. 이는 마치 느린 차량이 도로에서 앞을 막고 있고 뒤에 있는 빠른 차량들이 따라가지 못하는 상황과 비슷해 convoy effect 라고 부른다.

<details>
<summary><strong> convoy effect를 해결할 수 있는 다른 방법은 없을까요? </strong></summary>
<div markdown="1">

- SJN, SRTF: 짧은 작업을 먼저 처리하는 방식을 사용하면 convoy effect를 줄일 수 있다. 하지만 실행시간이 짧은 프로세스들이 계속해서 먼저 실행될 경우 긴 작업이 계속 대기하면서 기아 현상이 발생할 수 있다.

- 라운드 로빈: 일정한 시간마다 프로세스를 바꾸는 라운드로빈을 사용하면 한 프로세스가 너무 오랫동안 CPU를 독점하지 않게 할 수 있다.

- 다단계 큐 및 다단계 피드백 큐: 프로세스의 특성에 따라 다른 큐에 배치하고 우선 순위가 높은 작업을 빠르게 처리하며 convoy effect를 완화할 수 있다. 다단계 피드백 큐는 시간에 지남에 따라 프로세스를 다른 우선순위 큐로 이동시켜 공정성을 유지한다.

</div>
</details>

<details>
<summary><strong> CPU 스케줄링에서 기아현상이 발생하면 어떻게 해결할 수 있을까요? </strong></summary>
<div markdown="1">

- 에이징 기법: 시간이 지남에 따라 프로세스의 우선 순위를 점진적으로 증가시키는 방법을 사용한다. 대기 시간이 길수록 우선 순위를 높여서 결국 CPU를 할당받을 수 있도록 조정한다.

- 라운드 로빈: 모든 프로세스가 정해진 시간동안 CPU를 사용할 수 있도록 강제한다.

- 다단계 피드백 큐: 처음에는 낮은 우선 순위에서 실행되지만 오래 대기하면 자동으로 더 높은 우선순위 큐로 이동한다.

</div>
</details>

</div>
</details>

---

<details>
<summary><strong> CPU 스케줄링에서 Context Switch가 어떻게 이루어지나요? </strong></summary>
<div markdown="1">

현재 실행 중인 프로세스의 상태를 저장하고 새로운 프로세스의 컨텍스트를 로드한다. 현재 프로세스가 나중에 다시 실행될 때 저장된 상태에서 이어나갈 수 있도록 한다. 다음으로 CPU가 새로운 프로세스를 실행한다.

<details>
<summary><strong> Context Switch는 오버헤드가 있다고 하는데 이를 줄이기 위한 방법에는 무엇이 있을까요? </strong></summary>
<div markdown="1">

컨텍스트 스위칭 동안 CPU는 실제 연산을 수행하지 않고 문맥 저장 및 복구 작업만 수행한다. 그래서 프로세스 간 전환이 많아지면 성능 저하가 발생한다.

- 스레드 기반 프로그래밍 사용: 프로세스 간 전환보다 스레드 간 전환이 더 빠르다.

- 라운드 로빈의 타임퀀텀 최적화: 적절한 타임 퀀텀을 설정해 불필요한 컨텍스트 스위칭을 줄인다.

- 커널 스레드 대신 유저 스레드 활용: 유저 스레드는 커널 개입 없이 전환이 가능하다.

- TLB, 캐시 활용: 캐시 및 TLB를 최적화하여 새로운 프로세스로 전환할 때 성능 저하를 최소화한다.

</div>
</details>

<details>
<summary><strong> TLB는 무슨 역할을 할까요? </strong></summary>
<div markdown="1">

가상 주소를 물리 주소 변환하는 속도를 빠르게 하기 위한 캐시 메모리이다. 최근에 일어난 가상 메모리 주소와 물리 주소의 변환 테이블을 저장해두어서 CPU가 페이지 테이블을 거치지 않고 주소 변환을 빠르게 할 수 있도록 도와준다.

</div>
</details>

<details>
<summary><strong> PCB는 언제 생성되고 삭제되고, 생명주기동안 어떻게 관리될까요? </strong></summary>
<div markdown="1">

PCB는 프로세스가 생성될 때 운영체제에서 생성한다. 또한 PCB는 프로세스가 완료되거나 강제 종료될 때 운영체제가 PCB를 삭제한다. 운영체제는 프로세스 테이블을 사용하여 모든 PCB를 관리한다.

</div>
</details>

</div>
</details>

---

<details>
<summary><strong> CPU 스케줄링 방식은 언제 어디서 정해놓을까요? </strong></summary>
<div markdown="1">

운영체제에서 기본적으로 정해지며, 운영체제의 설정 값이나 특정 워크로드에 따라 변경이 가능하다.

<details>
<summary><strong> 동적으로 조정한다면 여러 스케줄링 방식이 있을 때 어떤 기준으로 선택할까요? </strong></summary>
<div markdown="1">

- CPU 사용량이 낮으면 FCFS
- 빠른 응답 시간이 필요하면 라운드로빈
- 실시간 시스템에서는 우선 순위 스케줄링
- 공정한 CPU 할당이 필요하면 멀티 레벨 큐
- 입출력 작업이 많을 때는 SJF

</div>
</details>

</div>
</details>
