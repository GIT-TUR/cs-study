## 📍프로세스 관리📍 목차

프로그램과 프로세스의 차이
프로세스 제어 블록 (PCB)
PCB의 구조
컨텍스트 스위칭 (Context Switching)
컨텍스트 스위칭이란?
컨텍스트 스위칭이 필요한 이유
컨텍스트 스위칭 동작 과정
컨텍스트 스위칭 발생 조건
프로세스의 메모리 영역
코드 영역
데이터 영역
Heap 영역
Stack 영역
스택 오버플로우 & 힙 오버플로우
프로세스의 상태
프로세스 상태
스터디 Chill문 모음
참고자료

### 1️⃣ 프로그램과 프로세스의 차이

#### 💥 프로그램 (Program)

- 실행되지 않은 정적 상태의 코드
- 보조기억장치(디스크)에 저장

#### 💥 프로세스 (Process)

- **실행 중인 프로그램**
- 운영체제에 의해 관리
- 메모리에 적재되고 CPU 자원을 할당받아 프로그램 실행

#### 💥 결론

프로그램은 실행되기 전에는 보조기억장치에 저장되어 있고, 프로그램을 메모리에 할당하고 실행하는 순간에는 프로그램이 **프로세스**가 된다.
![](https://velog.velcdn.com/images/jieun1ee/post/cc324bc4-dea6-495d-889d-007d3e72cf96/image.png)

### 2️⃣ 프로세스 제어 블록 (Process Control Block, PCB)

#### 💥 PCB

- **운영체제가 프로세스와 관련된 정보를 저장하는 자료 구조**
- 프로세스가 생성될 때 운영체제는 해당 프로세스의 정보를 저장하는 PCB를 생성하고, 프로세스가 종료되면 해당 PCB 삭제
- **커널 영역**에 생성
- 프로세스의 모든 필수 정보를 저장하기 때문에 **컨텍스트 스위칭** 가능
- 각 PCB에는 고유한 **프로세스 ID(PID)**가 존재해 구별이 가능

#### 💥 PCB의 구조

![PCB의 구조](https://velog.velcdn.com/images/jieun1ee/post/10a13030-7751-4e11-a986-a0808ffebcb5/image.png)

1. **포인터**
   - 프로세스의 **부모 프로세스를 가리키는 포인터**
   - 프로세스 계층 구조를 유지하는 데 사용
   - 커널에서 프로세스 테이블을 관리할 때 사용
2. **프로세스 상태**
   - 프로세스의 **현재 상태**를 저장
   - 프로세스 상태의 종류 :
     - New (생성): 새로운 프로세스가 생성됨
     - Ready (준비): CPU 할당을 기다리는 상태
     - Running (실행 중): CPU를 할당받아 실행 중인 상태
     - Waiting (대기 중): I/O 작업을 기다리는 상태
     - Terminated (종료됨): 프로세스 실행이 완료됨
3. **프로세스 ID (PID)**
   - 특정 프로세스를 식별하기 위해 부여하는 **고유한 번호**
   - 같은 프로그램을 여러 번 실행하면 각각 다른 PID를 가짐
   - 운영체제는 PID로 개별 프로세스를 추적
4. **프로그램 카운터(Program Counter, PC)**
   - 프로세스가 다음에 실행할 명령어의 **메모리 주소를 저장**하는 레지스터
   - 컨텍스트 스위칭 할 때 현재 실행 위치를 저장하고, 다시 실행할 때에 그 위치에서 시작
5. **레지스터**
   - 프로세스가 실행될 때 사용하는 **CPU 레지스터 정보** 저장
6. **메모리 제한**
   - 프로세스가 사용할 수 있는 **메모리 주소 공간 정보**
   - Base Address (기본 주소) : 프로세스가 시작하는 메모리 주소
   - Limit Address (한계 주소) : 프로세스가 접근할 수 있는 최댓값
7. **열린 파일 정보**
   - 해당 프로세스가 열어둔 **파일 목록**과 파일 디스크립터 저장
   - 파일 디스크립터 (File Descriptor)
     - 운영체제가 파일을 다룰 때 사용하는 정수형 식별자
     - PID처럼 프로세스가 파일을 열면 고유한 ID를 부여하고, 이를 통해서 파일을 관리

> **✔️ 현재 실행 중인 프로세스 명령어로 확인하기**
> ![](https://velog.velcdn.com/images/jieun1ee/post/fa389e5a-6d5c-4ac8-b580-aa8c4c78abef/image.png)터미널에 `ps aux` 명령어를 실행하면 현재 실행 중인 프로세스 목록과 일부 상태 정보를 확인할 수 있다.</br>맥의 경우 `활성 상태 보기`를 사용하면 쉽게 확인이 가능하다</br> - **USER(프로세스를 실행한 사용자)** : 해당 프로세스를 실행한 사용자의 계정 이름</br> - **PID(프로세스 ID)** : 프로세스의 고유한 식별 번호
> </br>- **%CPU(CPU 사용률)** : 프로세스가 현재 사용하는 CPU 리소스의 비율
> </br>- **%MEM(메모리 사용률)** : 프로세스가 전체 RAM에서 차지하는 메모리 비율
> </br>- **VSZ(Virtual Memory Size, 가상 메모리 크기)** : 프로세스가 사용 중인 가상 메모리 크기, 프로그램 코드, 데이터, 힙/스택 등이 포함
> </br>- **RSS(Resident Set Size, 실제 메모리 크기)** : 프로세스가 차지하는 실제 물리 메모리(RAM) 크기, VSZ와는 다르게 실제 메모리에서 차지하는 크기만 반영
> </br>- **TT(TTY, 터미널 정보)** : 프로세스가 연결된 터미널 정보, 백그라운드 프로세스라면 `??`로 표시
> </br>- **STAT(프로세스 상태)** : 현재 실행 상태
> </br>- **STARTED(프로세스 시작 시간)** : 프로세스가 실행된 시간 또는 날짜
> </br>- **TIME(누적 CPU 사용 시간)** : 프로세스가 실행되면서 사용한 누적 CPU 시간
> </br>- **COMMAND(실행된 명령어)** : 실행된 프로그램 또는 명령어

![프로세스테이블](https://velog.velcdn.com/images/jieun1ee/post/f5519658-1d1c-4136-8f89-30bf677b4794/image.png)
</br>운영체제는 빠르게 PCB에 접근하기 위해 `프로세스 테이블`을 사용하여 각 프로세스의 PCB를 관리

### 3️⃣ 컨텍스트 스위칭(Context Switching)

#### 💥 컨텍스트 스위칭이란

CPU가 실행 중인 프로세스를 변경할 때, 기존 프로세스의 상태를 저장하고 새로운 프로세스의 상태를 복원하는 과정. 즉, CPU가 한 프로세스에서 다른 프로세스로 전환될 때 수행되는 작업

#### 💥 컨텍스트 스위칭이 필요한 이유

1. 멀티태스킹(Multitasking) 지원
   - 여러 프로세스를 동시에 실행하는 것처럼 보이도록 하기 위해 필요
2. CPU 스케줄링(CPU Scheduling) 구현
   - 프로세스 우선순위에 따라 CPU를 적절히 배분하기 위해 필요
3. 인터럽트(Interrupt) 처리
   - I/O 요청, 시스템 콜, 인터럽트 발생 시 현재 상태를 저장하고 다른 작업을 처리하기 위해 필요

#### 💥 컨텍스트 스위칭 동작 과정

![](https://velog.velcdn.com/images/jieun1ee/post/933abe6d-1aea-4126-8f71-efe66a10d20d/image.png)

1. 실행 중인 프로세스1의 PCB에 현재 상태 저장
2. 새로 실행할 프로세스2의 PCB 정보를 로드
3. 프로세스2의 컨텍스트(레지스터, PC 등) 복원
4. CPU가 프로세스2를 실행

#### 💥 컨텍스트 스위칭 발생 조건

1. 멀티태스킹 환경에서 CPU 스케줄러가 프로세스를 변경할 때
   - 할당된 시간이 만료되어 다른 프로세스가 실행될 경우
2. I/O 또는 시스템 호출(System Call)로 인해 프로세스가 대기 상태가 될 때
   - 프로세스가 I/O 작업을 요청하여 Waiting 상태가 되면 CPU가 다른 프로세스를 실행
3. 프로세스 우선순위 변경 (Priority Preemption)
   - 더 높은 우선순위의 프로세스가 실행되어야 하는 경우
4. 인터럽트(Interrupt) 발생 시
   - 키보드 입력, 네트워크 이벤트, 타이머 인터럽트 등으로 인해 현재 프로세스를 중단하고 다른 작업을 수행할 때

### 4️⃣ 프로세스의 메모리 영역

![](https://velog.velcdn.com/images/jieun1ee/post/0748da1a-a07b-4e46-830f-64bb983fd574/image.png)</br>메모리는 크게 커널(Kernel) 영역과 유저(User) 영역으로 나뉘며, 커널 영역에는 운영체제가 적재되고 PCB가 생성된다.그리고 유저 영역의 프로세스 메모리 구조는 다시 몇 가지 구조로 나뉘어진다.

1. **코드 영역**
   - 텍스트 영역이라고도 함
   - 실행될 수 있는 코드, 즉 기계어로 이루어진 **명령어**가 저장됨
   - CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지
   - 따라서 코드 영역은 **읽기 전용**
2. **데이터 영역**
   - 프로그램이 실행되는 동안 유지할 **크기가 고정된 데이터**들이 저장되는 공간
   - Global 변수나 Static 변수가 저장
   - .data 영역 : 초기화된 전역/정적 변수 저장
   - .bss 영역 : 초기화되지 않은 전역/정적 변수 저장
3. **Heap 영역**
   - 프로그래머가 직접 할동할 수 있는 저장 공간
   - **동적 할당 변수**를 저장
   - 힙 영역에 공간을 할당(malloc(), new)을 했다면, 언젠가는 반환(free(), delete)해야함
   - 메모리 해제 안하면 **메모리 누수** 발생
   - 일반적으로 메모리의 낮은 주소에서 높은 주소로 할당
4. **Stack 영역**
   - 데이터 영역과는 다르게 데이터를 **일시적으로** 저장하는 공간
   - Local 변수, 매개 변수, 리턴 주소 등
   - **LIFO(Last-In, First-out)** 구조로 동작
   - 힙 영역과는 다르게 메모리의 높은 주소에서 낮은 주소로 할당해 주소가 겹칠 일이 없게 함

> ✔️ 추가
> </br>- 스택 오버플로우 : 스택 영역이 너무 깊어져서 충돌할 때 발생, 무한 재귀 호출 시에 발생 가능
> </br>- 힙 오버플로우 : 동적 할당된 메모리를 해제하지 않아 메모리가 고갈될 때 발생

### 5️⃣ 프로세스의 상태

#### 💥 프로세스 상태

- **생성 상태(New)**
  - 프로세스를 생성 중인 상태
  - 메모리에 적재되어 PCB를 할당 받은 상태
  - 생성 상태의 프로세스는 곧바로 실행되지 않고 준비 상태가 됨
- **준비 상태(Ready)**
  - CPU를 할당받아 실행할 수 있지만, 자신의 차례가 아직 아니기에 기다리고 있는 상태
  - 차례가 되면 CPU를 할당받아 실행 상태가 됨. 이 과정을 디스패치(Dispatch)라고 함.
- **실행 상태(Running)**
  - CPU를 할당 받아 실행 중인 상태
  - 실행 중인 프로세스는 할당된 일정 시간 동안만 CPU를 사용할 수 있음
  - 프로세스가 할당된 시간을 모두 사용한다면(타이머 인터럽트) 다시 준비 상태
  - 실행 도중 입출력장치를 사용하여 입출력 장치의 작업이 끝날 때까지 대기 상태
- **대기 상태(Waiting)**
  - I/O 작업은 CPU에 비해 처리 속도가 느리기에, 입출력 작업이 끝나기를 기다리는 상태
  - I/O 작업이 완료되면 해당 프로세스는 다시 준비 상태로 CPU 할당을 기다림
- **종료 상태(Terminated)** - 프로세스가 종료된 상태 - 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리
  ![](https://velog.velcdn.com/images/jieun1ee/post/601762f3-d60b-41f7-9a35-910ccc770a01/image.png)

---

### 🔥 스터디 Chill문 모음

-
-
-

---

📔 **참고자료**

- [혼자 공부하는 컴퓨터 구조 + 운영체제](https://m.yes24.com/Goods/Detail/111378840)
- [프로세스와 프로그램 차이 그림 출처](https://velog.io/@moonblue/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8program-%EA%B3%BC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process)
- [PCB 구조 그림 출처](https://yoongrammer.tistory.com/52)
- [컨텍스트 스위칭 그림 출처](https://hyunie-y.tistory.com/31)
- [프로세스 메모리 영역 그림 출처](https://velog.io/@mino0121/CSAlgorithm-Study-OS-Memory-structure)
- [프로세스 상태 다이어그램 그림 출처](https://itwiki.kr/w/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C)
