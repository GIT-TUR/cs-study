## 프로세스 관리 질문

<details>
    <summary>
        <strong style="font-size: 20px">1. 프로세스와 프로그램의 차이는 무엇인가요?</strong>
    </summary>
    프로그램은 실행되지 않은 정적 상태의 코드이며 디스크에 저장됩니다. 프로세스는 현재 실행 중인 프로그램이며 메모리에 적재됩니다. 운영체제에 의해 관리되고 CPU 자원을 할당받아 실행됩니다.
    <br/>
    <details>
        <summary>
            <strong>프로세스는 어떻게 관리되나요?</strong>
        </summary>
        프로세스 관리에는 여러가지가 있습니다.
        <ul>
          <li> 프로세스 상태 관리 : 새로 생성된 프로세스는 "New", CPU를 할당받아 실행 중일 때는 "Running", CPU를 기다리고 있을 때는 "Ready", I/O 작업이나 다른 이벤트를 기다릴 때는 "Blocked/Waiting", 실행을 마치면 "Terminated" 상태가 됩니다.
          <li> 프로세스 스케줄링 : 여러 프로세스 중 어떤 프로세스에 CPU를 할당해야 할지 결정해야 합니다. FCFS, SJF, Round Robin 등의 스케줄링 알고리즘이 있습니다.
          <li> 프로세스 간 통신 (IPC) : 운영체제는 파이프, 공유 메모리, 메시지 큐와 같은 IPC 메커니즘으로 정보를 교환합니다.
          <ul>
            <li>파이프 : 한 프로세스의 출력이 다른 프로세스의 입력으로 들어갑니다. 유닉스/리눅스에서 '|' 기호로 명령어들을 연결할 때 쓰는게 이거임
            <li>공유 메모리 : 특정 메모리를 여러 프로세스가 함께 쓸 수 있도록 합니다. 동기화 문제를 주의해야합니다.
            <li>메시지 큐 : 프로세스들이 메시지 형태로 데이터를 주고받을 수 있게 해주는 통신 방식입니다. 한 프로세스가 메시지를 큐에 넣어두면 다른 프로세스가 나중에 그 메시지를 가져가서 처리할 수 있습니다.
          </ul>          
          <li> 메모리 관리 : 각 프로세스는 자신만의 독립된 주소 공간을 필요로 하고, 운영체제는 물리적 메모리에 효율적으로 할당합니다. 가상 메모리 시스템을 통해 각 프로세스는 실제 물리적 메모리 크기보다 더 큰 주소 공간을 사용할 수 있습니다.
          <li> 프로세스의 생성과 종료 : 새로운 프로세스가 생성되면 필요한 자원을 할당하고, 종료되면 회수합니다.
        </ul>
        이 작업들은 모두 운영체제가 자동으로 수행합니다.
        <br/>
    </details>
    <br/>
    <details>
        <summary>
            <strong>프로세스 테이블은 무엇인가요? 프로세스 테이블의 PID와 PCB의 PID는 동일한가요?</strong>
        </summary>
        프로세스 테이블은 운영체제가 실행 중인 모든 프로세스의 정보를 관리하는 데이터 구조입니다. 프로세스 테이블의 각 항목은 해당 프로세스의 PCB를 가리키는 포인터를 포함합니다. 프로세스 테이블의 PID와 PCB의 PID는 동일합니다. 프로세스 테이블에도 같은 번호로 참조되고, PCB에도 같은 번호로 저장됩니다.
    </details>
    <br/>
    <details>
        <summary>
            <strong>좀비프로세스는 무엇인가요?</strong>
        </summary>
        실행이 완료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 확인하지 않아 완전히 제거되지 못한 프로세스입니다.
    </details>
</details>

<details>
    <summary>
        <strong style="font-size: 20px">2. 컨텍스트 스위칭 시에는 어떤 일이 일어나나요?</strong>
    </summary>
    컨텍스트 스위칭은 CPU가 실행 중인 프로세스를 변경할 때, 기존 프로세스의 상태를 저장하고 새로운 프로세스의 상태를 복원합니다. 먼저 CPU 레지스터 값들(프로그램 카운터, 스택 포인터 등), 메모리 관리 정보(페이지 테이블 등)을 PCB에 저장하고 새로운 프로세스의 PCB의 저장된 정보를 CPU 레지스터에 복원하고 메모리 관리 정보를 업데이트 하여 복원합니다.
    <br/>
    <details>
        <summary>
            <strong>컨텍스트 스위칭은 언제 일어나나요?</strong>
        </summary>
        <ul>
          <li>타이머 인터럽트가 발생할 때 : 운영체제는 각 프로세스에 일정 시간을 할당하는데, 이 시간이 끝나면 다른 프로세스로 전환합니다.
          <li>I/O 요청이 발생할 때 : 디스크 읽기는 오래걸리기 때문에 해당 작업이 완료될 때까지 다른 프로세스가 CPU를 사용할 수 있습니다.
          <li>프로세스가 자발적으로 CPU를 양보할 때 : sleep(), wait() 같은 시스템 콜을 호출할때
        </ul>
        <br/>
    </details>
    <br/>
    <details>
        <summary>
            <strong>프로세스와 스레드의 컨텍스트 스위칭의 차이는 무엇일까요?</strong>
        </summary>
        프로세스들은 메모리 공간, 페이지 테이블, 파일 디스크럽트가 독립적이고 스레드는 공유합니다. 따라서 자원을 공유하는 스레드 컨텍스트 스위칭이 더 빠릅니다.
    </details>
    <br/>
    <details>
        <summary>
            <strong>컨텍스트 스위칭이 발생하면, 기존 프로세스 정보는 어떻게 저장되나요?</strong>
        </summary>
        PCB에 저장됩니다. PCB에는 프로세스 식별자, 레지스터들의 주소와 값들(다음 실행할 명령어 위치, 범용 레지스터, 스택의 현재 위치 등), 메모리 정보(페이지 테이블 정보, 메모리 경계 정보 등), 기타 프로세스 상태 정보 등을 저장합니다.
    </details>
</details>

<details>
    <summary>
        <strong style="font-size: 20px">3. 프로그램과 프로세스의 관계는 몇대몇 일까요?</strong>
    </summary>
    프로그램이 레시피이면 프로세스는 요리라고 볼 수 있습니다. 하나의 프로그램은 여러 프로세스로 실행될 수 있습니다. 실제로 브라우저는 탭마다 프로세스를 가집니다.
    <br/>
</details>

<details>
    <summary>
        <strong style="font-size: 20px">4. 운영 체제에서 메모리를 할당할 때 힙와 스택 메모리 구조를 프로그래밍 언어 관점에서 설명할 수 있나요?</strong>
    </summary>
    스택은 함수 호출과 관련된 데이터를 저장하는 영역으로, 지역 변수와 함수의 매개변수가 저장됩니다. 힙은 프로그래머가 직접 메모리를 할당하고 해제하는 영역으로 동적으로 크기가 변하는 데이터를 다룰 때 주로 사용됩니다.
    <ul>
      <li>수명 관리 : 스택은 변수가 선언된 범위를 벗어나면 자동으로 해제됩니다. 힙은 프로그래머가 명시적으로 할당하고 해제해야함
      <li>할당 속도의 차이 : 스택은 단순히 스택 포인터를 이동하는거라 매우 빠릅니다. 힙은 메모리 블록을 찾고 분할 여부를 결정하고 헤더를 업데이트하고 반환하는 과정이 필요합니다.
      <li>메모리 한계 : 스택을 일반적으로 제한적인데 힙은 사용 가능한 메모리만큼 할당 가능합니다.
      <li>메모리 단편화 : 스택은 발생하지 않고 힙은 할당과 해제를 반복하면서 단편화가 발생할 수 있습니다.
    </ul>
    <br/>
    <details>
        <summary>
            <strong>자바스크립트 엔진의 메모리 관리를 설명해주세요</strong>
        </summary>
        자바스크립트 엔진의 메모리 관리는 운영체제의 메모리 관리를 추상화한 것입니다. 자바스크립트의 스택에는 small integer, 함수 호출 정보(실행 컨텍스트)가 저장됩니다. 힙에는 객체, 함수(함수도 객체임), 배열(배열도 객체임) 등이 저장됩니다. 실제 데이터는 힙에 저장되고 스택에는 그 데이터를 저장하는 참조만 저장됩니다. small integer는 스택에 직접 저장되고 명시적으로 힙 메모리를 해제해줘야 하는 운영체제와 달리 가비지 컬렉션이 자동으로 해제해줍니다.
        <br/>
    </details>
</details>

<details>
    <summary>
        <strong style="font-size: 20px">5. 프로세스 상태 전이 과정에 대해 설명해주세요.</strong>
    </summary>
    프로세스 상태 전이는 프로세스가 실행되는 동안 여러 상태들 사이를 이동하는것입니다. 상태에는 New, Ready, Running, Waiting, Terminated가 있습니다.
    <br/>
    <details>
        <summary>
            <strong>각 프로세스 상태가 변화하는 조건은 무엇인가요? 왜 그럴까요?</strong>
        </summary>
        <ul>
          <li>생성 → 준비 : 프로세스가 생성되고 운영체제가 이를 준비 큐에 추가합니다.
          <li>준비 → 실행 : 스케줄러가 준비 큐에서 프로세스를 선택에 CPU에 할당합니다. CPU 자원을 효율적으로 사용하기 위함입니다.
          <li>실행 → 대기 : 프로세스가 I/O을 요청하거나 다른 이벤트를 기다려야 할 때 CPU를 반납하고 대기 상태로 전이됩니다. 놀때 다른 프로세스를 실행하도록 하기 위함입니다.
          <li>대기 → 준비 : I/O 작업이 완료되거나 기다리던 이벤트가 발생하면 다시 준비상태로 전이합니다.
          <li>실행 → 종료 : 모든 작업을 마치면 종료상태로 전이됩니다.
        </ul>
        <br/>
    </details>
     <br/>
     <details>
        <summary>
            <strong>프로세스가 완료되면 어떤 상태로 종료되나요? 왜 그럴까요?</strong>
        </summary>
        종료 상태로 전이합니다. 운영체제가 해당 프로세스의 자원을 회수할 수 있고 이는 시스템 자원을 효율적으로 관리하기 위해 필요합니다.
        <br/>
    </details>
     <br/>
    <details>
        <summary>
            <strong>프로세스 상태 전이 5가지를 설명해주셨는데 추가로 더 없을까요? 더 있다면 각 상태를 상세히 설명하실 수 있나요? 각 상태를 나눈 이유가 무엇일까요?</strong>
        </summary>
        <ul>
          <li>일시 중단(Suspended) : 프로세스가 메모리에서 제거되어 디스크로 스왑 아웃된 상태. 메모리가 부족한 상황에서 사용됩니다.
          <li>재개(Resumed) : 일시 중단된 프로세스가 다시 메모리로 로드되어 준비 상태로 전이됩니다.
        <ul>
        시스템 자원의 효율적 관리와 프로세스의 우선순위 조정을 위해 사용됩니다.
        <br/>
    </details>
     <br/>
    <details>
        <summary>
            <strong>Node.js에서 이벤트 루프 관점으로 프로세스 상태 전이 과정을 설명할 수 있을까요 ? 예를 들어 네트워크 I/O를 보내면 프로세스는 어떠한 상태로 상태 전이가 될까요? 왜 그럴까요?</strong>
        </summary>
        메인 프로세스는 계속 ready - running 상태를 유지합니다. 네트워크 처리 프로세스는 ready로 대기하다가 네트워크 요청을 받으면 running 상태로 전환됩니다. 실제 네트워크 통신을 대기하면서는 waiting 상태로 전환되고 네트워크 응답이 오면 ready 상태로 돌아간 다음 running 상태가 되어 응답을 처리하고 node.js에 전달합니다. 이후에 다시 ready 상태로 돌아가 다음 작업을 기다립니다.
        <br/>
        <strong>Spring이라면?</strong>
        spring은 동기적으로 작동합니다. 따라서 ready 상태에서 시작하고 running 상태가 되어 요청을 처리합니다. 네트워크 I/O가 필요하면 waiting 상태로 전환되고 네트워크 응답이 오면 ready로 전환되고 running 상태가 되어 응답을 처리합니다.
    </details>
     <br/>
    <details>
        <summary>
            <strong>(백엔드라면) 데이터베이스로 커넥션에 쿼리 요청을 보내면 어떠한 상태로 프로세스가 상태 전이가 되는지 설명할 수 있나요 ? (typeORM과 같은 클라이언트가) 왜 그럴까요?</strong>
        </summary>
        여기도 메인 프로세스는 계속 ready - running 상태를 유지합니다. db 연결 프로세스도 ready로 대기하다가 쿼리 요청을 받으면 running 상태로 전환되고 waiting 상태로 대기하다가 응답을 받으면 ready 상태로 돌아간 후 running 상태가 되어 결과를 처리하고 node.js에 전달합니다.
        <br/>
    </details>
</details>

<details>
    <summary>
        <strong style="font-size: 20px">6. 프로세스 제어 블록(PCB)이란 무엇이며, 어떤 정보를 담고 있나요?</strong>
    </summary>
    PCB는 운영체제가 프로세스를 관리하기 위해 필요한 정보들을 담고 있는 데이터 구조입니다. 각 프로세스는 자신의 고유한 PCB를 가집니다.
    <ul>
      <li>프로세스 식별 정보
      <li>프로세스 상태 정보
      <li>메모리 관리 정보
      <li>입출력 상태 정보
    </ul>
    <br/>
    <details>
        <summary>
            <strong>PCB의 주요 구성 요소는 무엇인가요? (예: 프로세스 상태, 프로그램 카운터, CPU 레지스터 등)</strong>
        </summary>
         <ul>
          <li>프로세스 식별 정보
          <ul>
            <li>프로세스 ID(PID) : 각 프로세스의 식별자
            <li>부모 프로세스 PID : 해당 프로세스를 생성한 프로세스의 PID
            <li>사용자 ID : 프로세스를 실행한 사용자 정보
          </ul>
          <li>프로세스 상태 정보
          <ul>
            <li>프로세스 상태 : 실행, 준비, 대기 등
            <li>프로그램 카운터 : 다음에 실행할 명령어 주소
            <li>CPU 레지스터 : 프로세스가 CPU를 양보할 때 보존해야 할 레지스터 값들
            <li>CPU 스케줄링 정보 : 우선순위, 스케줄링 큐 포인터
          </ul>
          <li>메모리 관리 정보
          <ul>
            <li>메모리 경계 : 프로세스가 사용하는 메모리 시작과 끝 주소
            <li>페이지 테이블 : 가상 메모리 사용 시 페이지 정보
          </ul>
          <li>입출력 상태 정보
          <ul>
            <li>열린 파일 목록 : 프로세스가 사용 중인 파일들의 정보
            <li>입출력 장치 목록 : 할당된 입출력 장치들의 정보
          </ul>
        </ul>
        <br/>
    </details>
     <br/>
    <details>
        <summary>
            <strong>PCB는 메모리의 어디에 저장되나요?</strong>
        </summary>
        메모리는 커널 영역과 사용자 영역으로 나뉘며, 사용자 영역에 스택, 힙, 데이터, 텍스트 영역이 들어가고 커널 영역이 운영체제가 사용하는 영역으로 일반 프로그램은 접근할 수 없는 영역입니다. PCB는 이 커널 영역에 저장됩니다.
        <br/>
    </details>
</details>
