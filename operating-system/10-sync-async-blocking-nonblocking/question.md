# 비동기/동기 + 블로킹/논블로킹

## Q1 동기, 비동기란 무엇인가요?

특정 작업이 순서대로 실행되는지 순서대로 실행되지 않는지 차이이다.
순서대로 실행되지 않는다는 것은 작업의 완료 순서가 호출 순서와 일치하지 않을 수 있다는 의미이다.

## Q1-1 동기이면서 블로킹, 동기이면서 논블로킹인 것의 차이는 무엇인가요?

특정 작업이 순서대로 실행되면서 특정 작업이 중간에 특정 작업에 의해 진행이 멈추는지 멈추지 않는지 차이이다.
동기+블로킹은 작업이 완료될 때까지 제어권이 돌아오지 않으며, 동기+논블로킹은 작업을 요청한 후 제어권을 바로 돌려받지만 작업 완료 여부를 주기적으로 확인한다.

## Q2 블로킹, 논블로킹이란 무엇인가요?

블로킹은 한 작업이 진행 중일 때 다른 작업을 수행할 수 없도록 제어권을 가져가는 방식이다.
논블로킹은 작업을 진행하더라도 제어권을 바로 돌려주어 다른 작업을 수행할 수 있게 하는 방식이다.

## Q2-1 논블로킹 I/O를 수행하면 그 결과를 어떻게 수신할 수 있나요?

이벤트 방식 혹은 폴링 방식으로 가져올 수 있다.
확장해서 Push 모델과 Pull 모델이라고도 볼 수 있다.

- 이벤트 방식(Push): 작업 완료 시 콜백이나 이벤트를 통해 결과를 전달받음
- 폴링 방식(Pull): 주기적으로 작업 완료 여부를 확인하고 결과를 가져옴

## Q2-2 블로킹, 논블로킹은 동기, 비동기와 어떻게 다른 개념인가요?

블로킹/논블로킹은 제어권의 반환 여부에 초점을 맞춘 개념이고, 동기/비동기는 작업 수행 순서와 결과 처리 시점에 초점을 맞춘 개념이다.
블로킹/논블로킹은 주로 I/O 작업의 관점에서, 동기/비동기는 코드 실행 흐름의 관점에서 사용된다.

## Q3 동기+블로킹 방식의 핵심 원리를 설명해 주세요.

CPU 관점으로 생각하면 동기+블로킹은 모든 작업이 예측 가능하다.
요청한 작업이 완료될 때까지 제어권이 돌아오지 않으며, 작업 순서가 명확하게 보장된다. 작업 A가 끝나야만 작업 B가 시작되므로 흐름이 단순하고 직관적이다.

## Q3-1 동기+블로킹과 비동기+블로킹의 차이는 무엇인가요?

동기+블로킹은 작업이 완료될 때까지 대기하고 결과를 즉시 반환받는 반면, 비동기+블로킹은 작업을 요청하고 다른 작업을 수행할 수 없지만 결과는 나중에 처리한다.
비동기+블로킹은 실제로는 잘 사용되지 않는 방식으로, 블로킹되면서도 결과 처리를 나중에 한다는 점에서 장점이 제한적이다.

## Q4 동기+논블로킹에서 폴링을 사용하는 이유를 설명해주세요.

동기 방식이라는 것은 결국 어떤 작업이 순서에 맞춰 된다는 것이다.
한편 논블로킹은 작업에 블로킹되지 않고 된다는 것을 의미하는데 그렇다면 동기+논블로킹 방식은 동기적으로 실행되지만 비동기 방식을 지원한다는 관점에서 폴링은 동기+논블로킹을 구현할 수 있는 합리적인 수단으로 생각해볼 수 있다.
작업 요청 후 즉시 제어권을 돌려받지만(논블로킹), 작업 완료 여부를 지속적으로 확인(폴링)하여 완료 순서대로 처리(동기)한다.

## Q5 Node.js는 비동기+논블로킹을 어떻게 구현했을까요?

이벤트 루프를 통해 구현했다. Node.js는 단일 스레드 이벤트 루프 모델을 사용하여 I/O 작업을 비동기적으로 처리한다. 작업을 요청하고 즉시 제어권을 반환받아 다른 작업을 수행할 수 있게 하며, 작업이 완료되면 콜백이나 프로미스를 통해 결과를 처리한다.

## Q6 Node.js에서는 비동기+논블로킹으로만 동작할까요? 그렇다면 왜 그런지 아니라면 어떻게 동작할 수 있는지도 설명해주세요.

이벤트 루프기반으로 비동기+논블로킹을 지원한다가 엄밀한 의미에서 정확하다.
따라서 동기+블로킹도 권장되지 않지만 가능하다.
Node.js는 기본적으로 비동기+논블로킹 방식을 권장하지만, fs.readFileSync()와 같은 동기식 API도 제공한다. 이런 동기식 API는 메인 스레드를 블로킹하므로 성능 저하를 일으킬 수 있어 가급적 사용을 피하는 것이 좋다.

## Q7 이벤트 루프 방식 외에 비동기 프로그래밍을 구현한 방식은 어떤게 있을까요?

멀티 스레드, 코루틴 등이 있다.

- 멀티 스레드: 여러 스레드를 사용해 동시에 여러 작업을 처리
- 코루틴: 협력적 멀티태스킹을 통해 함수의 실행을 중단하고 재개할 수 있는 기능
- 액터 모델: 독립적인 엔티티(액터)가 메시지를 주고받으며 비동기적으로 동작
- 리액티브 프로그래밍: 데이터 스트림과 변화 전파에 중점을 둔 비동기 프로그래밍 패러다임

## Q7-1 이벤트 루프를 사용하는 이유에 대해서

이벤트 루프의 기본적인 동작 방식은 특정 작업이 오래 걸리기 때문에 다른 곳에 위임한다는 아이디어를 가지고 있다 일반적으로 OS 관점으로 생각해보면 CPU가 아닌 I/O 작업이 그러하다.
이벤트 루프 방식은 특정 작업이 CPU 집약이거나 각종 I/O 작업으로 인해 블로킹되는 것을 방지하고나 다른 곳에 위임한다. 따라서 블로킹되지 않는 논 블로킹 I/O 방식이라고도 한다.

이벤트 루프는 단일 스레드로도 효율적인 동시성을 구현할 수 있게 해주며, 멀티 스레드 방식에 비해 스레드 생성과 컨텍스트 스위칭 오버헤드가 없고, 공유 자원에 대한 동기화 문제(락, 데드락 등)를 피할 수 있다는 장점이 있다.
