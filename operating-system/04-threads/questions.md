# Q1. - 비동기 프로그래밍과 멀티스레드 프로그래밍의 차이점을 설명해주세요.

답변: 일반적으로 멀티스레드 프로그래밍 방식은 동기적인 방식이고, 비동기 프로그래밍은 싱글 스레드 방식이면서 비동기 방식으로 하는 것으로 알려져 있습니다.

그러나 Go와 같은 언어는 비동기 프로그래밍과 스레드 프로그래밍을 모두 지원하고 자바도 마찬가지로 WebFlux와 같은 기술을 활용하여서 비동기 프로그래밍을 지원하며, Node.js도 워커 등을 활용하면 멀티스레드 프로그래밍이 가능합니다.

## Q1.1 - 스레드 풀과 코루틴의 차이점을 설명해주세요

답변: 미리 생성된 OS 레벨의 스레드를 재사용하여 작업을 처리하는 기법입니다. 스레드를 생성/종료하는 비용이 커서 미리 생성하여 사용하는 것이 스레드 풀이고, 코루틴은 cooperative multitasking을 통해 실행 흐름을 제어합니다.
단일 스레드 내에서 동시성을 구현하고, 명시적으로 suspend와 resume를 하여 실행 흐름을 제어한다는 특징이 있습니다.

### Q1.1.1 - 코루틴의 suspend 함수는 어떻게 동작하나요?

답변: suspend 함수는 코루틴 내부에서 실행 중인 작업을 일시 중단(suspend)하는 역할을 합니다.
일시 중단된 코루틴은 현재 상태(지역 변수, 실행 위치 등)를 보존하고, 호출한 스레드를 블로킹하지 않으면서 다른 작업이 진행될 수 있도록 합니다.
이후 적절한 시점에 resume 또는 다른 재개 메커니즘을 통해 중단된 위치부터 실행이 계속됩니다.

### Q1.1.2 - 코루틴의 스코프와 컨텍스트의 차이점은?

답변: 코루틴 스코프 (Coroutine Scope)는 코루틴의 생명주기를 관리합니다.

스코프 내에서 실행되는 모든 코루틴은 스코프가 종료되면 함께 취소됩니다.
예를 들어, UI 애플리케이션에서는 액티비티나 프래그먼트의 라이프사이클에 맞춰 코루틴 스코프를 설정합니다.

코루틴 컨텍스트 (Coroutine Context)은 코루틴이 실행될 때 사용할 스레드 디스패처, Job, 예외 처리기 등 실행 관련 정보를 담고 있습니다.

스레드 전환, 우선순위, 취소 정책 등의 세부 실행 환경을 설정할 수 있습니다.
스코프와는 달리 코루틴 내부에서 실행 환경(예, Dispatchers.IO, Dispatchers.Main 등)을 결정합니다.

### Q1.1.3 - 코루틴의 취소 매커니즘은 어떻게 동작하나요?

답변:

코루틴은 협력적 취소(cooperative cancellation) 방식을 사용합니다
코루틴은 주기적으로 isActive 플래그를 확인하거나, 취소가 가능한 suspend 함수에서 자동으로 취소 여부를 체크합니다.

취소 요청이 발생하면 CancellationException을 발생시키며, 이를 통해 실행 중인 코루틴이 안전하게 종료됩니다.
강제 종료 대신 협력적으로 취소를 처리함으로써, 자원 정리(clean-up)나 후처리 작업을 수행할 수 있게 합니다.

## Q1.2 - Promise 패턴은 무엇이며 어떤 상황에서 유용한가요?

답변: 비동기 작업의 완료(성공 또는 실패)를 나타내는 객체로, 미래의 값을 약속하는 개념입니다.
작업의 결과가 준비되면 .then(), .catch() 등의 메서드를 통해 후속 작업을 연결할 수 있습니다.
비동기 작업의 순차적 처리를 명확하게 표현할 수 있으며, 에러 핸들링을 중앙집중식으로 관리할 수 있습니다.

일반적으로 복잡한 비동기 연산에서 callback hell을 피하는 문제가 있습니다. 또한 비동기 체인을 구성할 때 유리합니다.

# Q2 스레드란 무엇이며, 프로세스와의 차이점을 설명해주세요.

답변: 스레드는 프로세스 내에서 실행되는 가장 작은 실행 단위로, 같은 프로세스 내의 다른 스레드와 메모리(힙, 전역 변수)를 공유합니다. 프로세스는 독립된 실행 단위로, 각 프로세스는 자체 메모리 공간(힙, 데이터, 코드 영역 등)을 가지고 있습니다.

## Q2.1 - 프로세스 간 통신(IPC)과 스레드 간 통신의 차이점과 각각의 장단점은 무엇인가요?

답변: 각 프로세스는 별도의 메모리 공간을 가지므로, 메시지 큐, 파이프, 소켓, 공유 메모리 등 OS에서 제공하는 다양한 기법을 사용하여 데이터를 주고받습니다. 스레드 간 통신은 같은 프로세스 내의 스레드는 메모리를 공유하므로, 변수나 객체에 직접 접근할 수 있습니다.

## Q2.2 - 컨텍스트 스위칭이 발생할 때 어떤 정보들이 저장되고 복원되나요?

답변:

레지스터 값: CPU 레지스터, 프로그램 카운터(PC), 스택 포인터 등 현재 실행 상태를 나타내는 정보
프로세서 상태: 플래그 레지스터, 상태 레지스터 등
메모리 맵: 각 스레드나 프로세스의 스택 정보(지역 변수, 함수 호출 정보 등)

## Q2.3 - 프로세스의 자식 프로세스 생성 과정을 설명해주세요

답변:

fork() 시스템 콜을 사용하여 부모 프로세스의 거의 전체 메모리(복사-온-라이트 방식)를 자식에게 복제한 후,
필요에 따라 exec()를 호출해 새로운 프로그램 코드로 교체합니다.

## Q2.4 - 스레드 로컬 스토리지(TLS)는 어떤 상황에서 사용하나요?

답변: 각 스레드마다 독립적으로 유지되어야 하는 데이터(예: 임시 캐시, 스레드별 에러 상태, 세션 정보 등)를 저장할 때 사용합니다.
전역 변수와 달리, 스레드 간 데이터 간섭 없이 독립적인 저장소를 제공하여 동시성 문제를 완화합니다.

# Q3 스레드의 생명주기(Lifecycle)에 대해 설명하고, 각 상태 간의 전이가 발생하는 조건을 설명해주세요.

답변:

주요 상태:

- New: 스레드 객체가 생성되었으나 아직 시작되지 않은 상태.
- Runnable: 실행 준비가 완료되어 OS 스케줄러에 의해 실행 대기 중인 상태.
- Running: 실제로 CPU에서 실행 중인 상태.
- Blocked/Waiting: 동기화, I/O 대기, 혹은 특정 조건이 충족될 때까지 일시 중단된 상태.
- Terminated: 실행을 마치고 종료된 상태.

전이 조건:

- start() 호출 시 New → Runnable
- 스케줄러에 의해 선택되면 Runnable → Running
- I/O 대기, lock 획득 대기 등으로 Running → Blocked/Waiting
- 조건이 해소되면 Blocked/Waiting → Runnable
- 작업 완료 혹은 예외 발생 시 Running → Terminated

## Q3.1 - BLOCKED와 WAITING 상태의 차이점은 무엇이며, 각각 어떤 상황에서 발생하나요?

답변:

BLOCKED

- 의미: 스레드가 동기화 블록이나 메서드에 접근하기 위해 lock 획득을 기다리는 상태.
- 발생 상황: 다른 스레드가 특정 모니터(락)를 소유하고 있어, 해당 모니터를 획득할 수 없는 경우.

WAITING

- 의미: 스레드가 명시적으로 기다림(wait) 상태에 들어가, 다른 스레드가 특정 조건이나 알림(notify)을 줄 때까지 무한 대기하는 상태.

## Q3.2 - suspend()와 resume() 메서드가 deprecated된 이유는 무엇인가요?

답변:

문제점:
강제적으로 스레드를 일시 중단 및 재개하는 방식은,
만약 스레드가 중요한 자원을 점유한 상태에서 suspend되면 데드락이나 자원 불일치 문제를 유발할 수 있습니다.

## Q3.2 - 스레드의 interrupt() 메서드는 정확히 어떻게 동작하나요?

답변:

interrupt()는 대상 스레드의 인터럽트 플래그를 설정합니다.

만약 스레드가 차단(blocked) 상태(예: sleep, wait, join)라면, 해당 메서드는 InterruptedException을 발생시켜 스레드를 깨웁니다.

실행 중인 스레드는 주기적으로 인터럽트 상태를 확인하여, 필요 시 안전하게 종료하거나 적절한 처리를 할 수 있습니다.

### Q3.3.1 스핀락과 뮤텍스의 차이점은?

답변:

스핀락 (Spinlock)

- 특징: 락을 획득할 때까지 루프를 돌며 바쁜 대기(busy waiting)를 합니다.
  짧은 시간 내에 락이 해제될 것으로 예상되는 경우에 유리합니다.
- 장단점: 오버헤드가 적으나, 대기하는 동안 CPU 사이클을 소모합니다.

뮤텍스 (Mutex)

- 특징: 락을 획득하지 못하면 스레드를 블록(block)하여 CPU 자원을 다른 작업에 사용할 수 있도록 합니다.
- 장단점: 상대적으로 오버헤드가 크지만, 장시간 대기가 예상될 때 효율적입니다.

## Q3.4 - 데몬 스레드와 일반 스레드의 차이점은 무엇인가요?

답변:

데몬 스레드

- 백그라운드에서 실행되며, JVM이나 프로세스 종료 시 함께 종료됩니다.
- 일반적으로 서비스나 보조 작업(예: 가비지 컬렉션, 모니터링)에 사용됩니다.

일반 스레드 (User Thread)

- 프로세스의 주요 작업을 수행하며, 모든 일반 스레드가 종료되어야 프로세스가 종료됩니다.

## Q3.5 데몬 스레드의 가비지 컬렉션 처리는?

답변:

JVM을 예시로 들면 데몬 스레드도 일반 스레드와 같이 GC 대상에 포함됩니다.
단, 데몬 스레드는 프로세스 종료에 영향을 주지 않으므로, JVM 종료 시 강제 종료될 수 있습니다.
GC 수행 방식 자체에는 차이가 없으며, 메모리 회수 시점은 GC 알고리즘에 따릅니다.

# Q4 멀티 스레드 프로그래밍할 때 스레드 개수는 몇 개를 생성하는게 좋을까요 ?

답변:

CPU 바운드 작업: 일반적으로 CPU 코어 수와 같거나 약간 초과하는 수준(예: 코어 수 혹은 코어 수 + 1)이 적당합니다.

I/O 바운드 작업: I/O 대기 시간에 따라 더 많은 스레드가 필요할 수 있으며, 과도한 스레드 생성은 오히려 문맥 전환 오버헤드를 초래할 수 있습니다.

## Q4.1 - ThreadPool의 크기를 동적으로 조절하는 방법과 그 장단점에 대해 설명해주세요

답변:

동적 조절 알고리즘: 작업 큐의 길이, 현재 활성 스레드 수, CPU 사용률 등을 모니터링하여 스레드를 추가하거나 제거합니다.

예를 들어, Java의 ThreadPoolExecutor에서는 코어 풀과 최대 풀 크기, 그리고 유지 시간(keep-alive time) 등을 설정하여 동적 확장이 가능합니다.

### Q4.1.1 - 캐시드 스레드 풀과 픽스드 스레드 풀의 차이점은?

답변:

캐시드 스레드 풀 (Cached Thread Pool)

- 특징: 필요 시 새로운 스레드를 생성하고, 일정 시간 동안 유휴 상태인 스레드는 종료합니다.
- 장점: 부하가 갑자기 증가할 경우 빠르게 스레드를 생성하여 대응 가능.

픽스드 스레드 풀 (Fixed Thread Pool)

- 특징: 미리 정해진 일정한 수의 스레드를 사용하며, 초과 작업은 큐에 대기합니다.
- 장점: 시스템 자원을 예측 가능하게 사용하며, 과도한 스레드 생성으로 인한 오버헤드를 방지합니다.

### Q4.1.2 - 작업 큐의 백프레셔 처리 방법은?

답변:

작업 거부 정책 (Rejection Policy):

- 작업 큐가 가득 찬 경우, CallerRunsPolicy, AbortPolicy, DiscardPolicy 등 정책을 통해 새 작업을 처리하거나 거부합니다.

백프레셔 신호:

- 생산자 측에 작업 속도를 줄이도록 신호를 보내거나, 큐의 상태를 모니터링해 동적으로 처리량을 조절합니다.

### Q4.1.3 - 스레드 풀 모니터링 전략은?

답변:

모니터링 도구: JMX, 로그, 애플리케이션 모니터링 시스템을 통해 활성 스레드 수, 큐 길이, 평균 작업 시간 등을 실시간으로 추적합니다.
알림 설정: 특정 임계치를 초과하면 경고를 발생시켜, 스레드 풀의 이상 상태를 조기에 발견할 수 있습니다.

### Q4.1.4 - ForkJoinPool은 언제 사용하면 좋을까요?

답변:

분할 정복 알고리즘: 큰 작업을 여러 하위 작업으로 분할한 후, 병렬로 처리하고 결과를 합치는 경우.

CPU 집약적 작업: 작업 간의 균형이 잘 맞고, 작업 재분배(work stealing)가 유리한 상황에서 사용됩니다.

## Q4.2 - 스레드 풀의 작업 큐가 가득 찼을 때 어떻게 처리하는 것이 좋을까요?

답변:

- 거부 정책 적용: 작업을 즉시 거부하거나, 호출한 스레드에서 직접 실행(CallerRunsPolicy)하는 정책을 사용할 수 있습니다.
- 외부 큐 사용: 작업 큐 외부에 추가 큐를 두어 백프레셔를 관리하거나, 생산자 측에 작업 속도를 조절하도록 신호를 보냅니다.
- 큐 사이즈 조정: 상황에 따라 큐의 크기를 동적으로 확장하는 방법도 고려해 볼 수 있습니다.

## Q4.3 - 스레드 풀에서 작업자 스레드가 죽었을 때 어떻게 처리해야 할까요?

답변:

- 자동 복구: 대부분의 스레드 풀 구현체는 작업자 스레드가 예기치 않게 종료되면, 새 스레드를 생성하여 교체합니다.
- 모니터링 및 로그: 주기적인 모니터링과 로깅을 통해 스레드 종료 원인을 파악하고, 필요 시 시스템 설정이나 코드를 수정합니다.

## Q4.4 - 워커 스레드와 이벤트 루프의 차이점은 무엇인가요?

답변:

워커 스레드

- 각각의 스레드가 독립적으로 작업을 수행하며, 병렬 처리가 가능합니다.

이벤트 루프

- 단일 스레드 내에서 비동기 이벤트를 순차적으로 처리하는 구조로, 콜백이나 코루틴을 활용하여 논블로킹 방식으로 작업을 수행합니다.
  주요 차이: 워커 스레드는 병렬 처리에 적합하고, 이벤트 루프는 단일 스레드 내에서 경량 비동기 작업 처리에 적합합니다.

# Q5 False Sharing이 무엇일까요

답변:

False Sharing은 서로 독립적인 변수들이 같은 캐시 라인에 위치할 때, 한 스레드가 변수 값을 변경하면 동일 캐시 라인을 사용하는 다른 스레드의 캐시 무효화(cache invalidation)가 발생하여 성능 저하를 유발하는 현상입니다.

## Q5.1 - 캐시 라인 크기는 어떻게 확인할 수 있으며, 이를 고려한 최적화 경험이 있나요?

답변:

시스템 프로파일링 도구나 라이브러리(예: sysconf, cpuid 명령어 등)를 통해 확인할 수 있습니다.

## Q5.2 - L1, L2, L3 캐시의 특징과 각각의 역할은 무엇인가요?

답변:

L1 캐시

- 특징: 가장 작고 빠르며, 각 코어에 독립적으로 존재합니다.
- 역할: CPU가 가장 빈번하게 사용하는 데이터를 저장합니다.

L2 캐시

- 특징: L1보다 크지만 속도는 다소 느리며, 코어별 또는 소규모 그룹별로 공유될 수 있습니다.
- 역할: L1 캐시 미스 시 데이터를 제공하며, 중간 단계의 캐시 역할을 합니다.

L3 캐시

- 특징: 모든 코어가 공유하는 경우가 많으며, 가장 크고 상대적으로 느립니다.
- 역할: 전체 시스템의 데이터 일관성을 유지하고, L2 미스 시 데이터를 제공합니

## Q5.3 - CPU 캐시 일관성 프로토콜은 어떻게 동작하나요?

답변:

MESI 프로토콜

구성: Modified, Exclusive, Shared, Invalid 네 가지 상태를 사용합니다.

동작 원리:

- 한 스레드가 캐시 라인에 쓰기 작업을 하면, 해당 캐시 라인의 상태가 Modified 상태로 전환되고, 다른 코어의 캐시에서 해당 라인은 Invalid 처리되어 데이터 일관성을 유지합니다.

## Q5.4 - Write-through와 Write-back 캐시 정책의 차이점은 무엇인가요?

답변:

Write-through

- 특징: 데이터가 캐시에 기록될 때, 동시에 주 메모리에도 기록됩니다.
- 장점: 주 메모리와 캐시 간의 일관성이 항상 유지됩니다.
- 단점: 쓰기 성능이 다소 저하될 수 있습니다.

Write-back

- 특징: 데이터는 우선 캐시에 기록되고, 캐시 라인이 교체될 때 주 메모리에 반영됩니다.
- 장점: 쓰기 성능이 향상되며, 주 메모리 접근 횟수를 줄일 수 있습니다.
- 단점: 캐시와 메모리 간의 일관성을 유지하기 위한 복잡한 관리가 필요합니다.

# Q6 스레드는 왜 스택과 힙 중에서 스택만 할당받을까요 ?

답변:

스레드는 자신만의 함수 호출, 지역 변수, 반환 주소 등을 저장하기 위해 독립된 스택을 할당받습니다.

반면, 힙은 프로세스 전체에서 공유되어 동적으로 생성된 객체들이 저장되며, 모든 스레드가 공동으로 접근합니다.

이러한 분리는 함수 호출의 독립성과 실행의 안정성을 보장합니다.

## Q6.1 - 스레드 스택 크기는 어떻게 결정되며, 스택 오버플로우를 방지하기 위한 방법은 무엇인가요?

답변:

- 결정 방식: 운영체제나 JVM, 언어 런타임에서 기본값을 제공하며, 필요에 따라 명시적으로 조정할 수 있습니다.

- 방지 방법: 재귀 호출의 깊이를 줄이거나, 꼬리 재귀 최적화(Tail Recursion Optimization)를 활용합니다.
  스택 사용량이 많은 경우, 스택 크기를 늘리거나 알고리즘을 반복문 기반으로 전환하는 등의 방법을 적용합니다.

### Q6.1.1 - MESI 프로토콜의 각 상태는 무엇을 의미하나요?

답변:

Modified (M):
캐시 라인에 있는 데이터가 수정되어, 주 메모리와 일치하지 않으며, 해당 캐시만이 최신 데이터를 보유합니다.

Exclusive (E):
캐시 라인에 있는 데이터가 주 메모리와 동일하며, 오직 해당 캐시에만 존재하는 상태입니다.

Shared (S):
캐시 라인에 있는 데이터가 여러 캐시에 복사되어 있으며, 모두 주 메모리와 일치하는 상태입니다.

Invalid (I):
캐시 라인에 있는 데이터가 더 이상 유효하지 않은 상태입니다.

### Q6.1.2 - 캐시 미스의 종류와 각각의 해결 방법은?

답변:

컴펄서리 미스 (Compulsory Miss):
캐시에 처음 접근할 때 발생하는 미스.
해결 방법: 프리페칭(prefetching) 기법을 통해 미리 로드할 수 있음.

용량 미스 (Capacity Miss):
캐시의 크기가 부족해 발생하는 미스.
해결 방법: 캐시 크기를 늘리거나, 데이터 접근 패턴을 최적화.

충돌 미스 (Conflict Miss):
캐시 라인이 여러 데이터에 의해 공유되어 발생하는 미스.
해결 방법: 데이터 정렬이나 패딩을 통해 캐시 라인 충돌을 줄임.

### Q6.1.3 - 캐시 일관성과 메모리 일관성의 차이는?

답변:

캐시 일관성 (Cache Coherence)
여러 코어의 캐시 간에 동일한 메모리 위치의 데이터가 일관되도록 유지하는 메커니즘입니다.

메모리 일관성 (Memory Consistency)
시스템 전체에서 메모리 연산(읽기/쓰기)의 순서가 예측 가능한 규칙에 따라 수행되도록 보장하는 모델입니다.

### Q6.1.4 - NUMA 아키텍처에서의 최적화 전략은?

답변:

메모리 지역성:

스레드가 로컬 노드의 메모리에 접근하도록 스레드와 데이터를 할당합니다.

바인딩:

스레드를 특정 NUMA 노드에 고정하여, 크로스 노드 접근을 최소화합니다.

## Q6.2 - 가비지 컬렉션이 스레드 실행에 미치는 영향은 무엇인가요?

답변:

가비지 컬렉션(GC)은 필요 시 스레드 전체를 일시 정지(Stop-the-World)를 유발할 수 있어, 응답 시간이 지연될 수 있습니다.
최신 GC 알고리즘은 짧은 중단 시간(mini pause)과 병렬 GC를 통해 이러한 영향을 최소화하도록 설계되어 있습니다.

## Q6.3 - 스택 프레임이 정확히 어떤 정보들을 포함하고 있나요?

답변:

- 반환 주소: 호출된 함수가 끝난 후 돌아갈 위치
- 지역 변수: 함수 내에서 선언된 임시 변수들
- 함수 매개변수: 호출 시 전달된 인자 값들
- 저장된 레지스터 값: 함수 호출 전의 CPU 레지스터 상태 등
- 프레임 포인터: 이전 스택 프레임의 기준을 나타내는 포인터

# Q7 실행의 흐름이 정확히 무슨 뜻인지 설명해주세요

답변:

프로그램 내에서 명령어가 실행되는 순서, 분기, 함수 호출, 반복문 등의 제어 흐름을 의미합니다.
그리고 이러한 흐름은 엄밀하게 이야기하면 CPU의 코어가 코드를 한줄 한줄 읽어가는 과정이라고 할 수 있습니다.

## Q7.1 - 실행 흐름을 추적하고 디버깅하는 효과적인 방법은 무엇인가요?

답변: 로깅, 디버깅, 프로파일러 등이 있습니다.

### Q7.1.1 - 스레드별 메모리 릭 추적 방법은?

답변:

메모리 프로파일링 도구:
VisualVM, YourKit, 혹은 Valgrind 같은 도구를 사용하여 각 스레드의 메모리 사용 현황을 모니터링합니다.

스레드 로컬 로깅:
각 스레드별로 메모리 할당과 해제 시점을 기록하여, 릭(leak) 가능성을 분석합니다.

주기적 스냅샷:
힙 덤프를 주기적으로 생성하여, 스레드별 메모리 사용량의 변화와 비정상적인 증가를 확인합니다.

## Q7.2 - 멀티스레드 환경에서 데드락을 탐지하는 방법은 무엇인가요?

답변:

스레드 덤프 분석:
모든 스레드의 상태와 락 보유 상태를 확인하여 순환 대기(circular wait) 상황을 파악합니다.

정적 분석 도구:
코드 상의 락 순서를 분석해 잠재적 데드락 상황을 사전에 경고합니다.

런타임 모니터링:
타임아웃 설정 및 데드락 탐지 알고리즘(예: wait-for 그래프)을 통해 실행 중 데드락을 감지합니다.

## Q7.3 - 프로파일링 도구는 어떤 것들을 사용해보셨나요?

답변:

### Q7.3.1 - 힙 덤프와 스레드 덤프의 차이점은?

답변:

힙 덤프:
프로세스의 메모리 상태, 객체 할당, 참조 관계 등을 포함한 전체 메모리 스냅샷.

스레드 덤프:
각 스레드의 현재 상태, 스택 트레이스, 락 보유 상황 등을 기록하여 스레드의 실행 상태와 동기화 문제를 분석하는 데 사용됩니다.

### Q7.3.2 - 디버거의 브레이크포인트 동작 원리는?

답변:

소스 코드의 특정 지점에 브레이크포인트를 설정하면, 해당 지점에 도달했을 때 실행을 일시 중지합니다.

이 과정에서 CPU 레지스터, 스택 상태 등의 현재 실행 상태를 보존하여 개발자가 코드 상태를 분석할 수 있도록 합니다.

내부적으로는 인터럽트나 코드 인젝션 방식을 사용하여 실행 흐름을 제어합니다.

## Q7.3.3 - 프로파일러가 성능에 미치는 영향은?

답변:

프로파일러는 프로그램 실행 중 추가적인 모니터링을 수행하므로, 오버헤드가 발생할 수 있습니다.

샘플링 기반 프로파일러: 주기적으로 스냅샷을 찍어 오버헤드를 최소화하려고 합니다.

인스트루먼테이션 기반 프로파일러: 함수 호출마다 코드를 삽입하여 측정하므로, 실행 속도가 다소 느려질 수 있습니다.
