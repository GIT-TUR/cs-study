## 프로세스 동기화 질문

<details>
  <summary><h3>1. 프로세스 동기화가 필요한 이유는 무엇인가요?</h3></summary>
  프로세스 동기화가 필요한 이유는 공유 자원에 대한 일관성 유지와, 프로세스들이 경쟁 상태(race condition)에 놓이지 않게 하기 위해서 순서를 제어해주어야하기 때문에 필요합니다.
  
  만약 여러 프로세스들이 하나의 자원을 두고 경쟁을 벌이는데 순서를 제어하지 않는다면 모두가 자원을 사용하지 못하는 문제나 함께 접근해서 공유 자원의 일관성을 깨뜨릴 수 있기 때문입니다.

  <br/> 
  
  <details>
    <summary>
      <strong>동기화의 목적은 무엇이고, 동기화 문제가 발생할 수 있는 대표적 상황은 어떤 것이 있을까요?</strong>
    </summary>
    <br/>
      <ul>
        <li> 데이터 일관성 유지
        <li> 실행 순서 제어
        <li> 상호 배제 보장
        <li> 교착 상태 방지
      </ul>
      목적은 위와 같고, 동기화 문제가 발생할 수 있는 대표적 상황에는 두 개 이상 프로세스가 서로 상대방이 점유하는 자원을 기다리며 무한 대기 상태에 빠지는 교착 상태 문제라거나, 생산자가 데이터를 생산하고 소비자가 이를 소비하는 상황에서 버퍼 크기를 관리하는 문제 등이 있습니다.
  </details>
  <br/>
  <details>
    <summary>
      <strong>임계 구역이란 무엇인가요? 그리고 임계 구역에서 발생하는 문제를 해결하기 위한 조건에는 무엇이 있을까요?</strong>
    </summary>
    <br/>
    임계 구역(critical section)은 여러 프로세스가 공유하는 자원에 접근하는 코드 영역을 의미합니다. 임계 구역에서 발생하는 문제를 해결하는 방법은 다음과 같습니다. 
      <ul>
        <li> 상호 배제(mutual exclusion)를 통해 한 번에 하나의 프로세스만 임계 구역에 진입할 수 있도록 합니다.
        <li> 진행(progress)으로 임계 구역에 있는 프로세스가 없다면 진입하려는 프로세스가 진입할 수 있어야 합니다.
        <li> 유한 대기(bounded waiting)로 프로세스의 임계 구역 진입이 무한 연기되어서는 안됩니다.
      </ul>
  </details>
</details>

<br/>

<details>
  <summary><h3>2. 세마포어는 무엇인가요?</h3></summary>
  세마포어는 프로세스 동기화 도구로, 정수 값을 가지는 변수와 두 개의 원자적 연산 P, V 연산으로 구성됩니다. 정수 값은 사용 가능한 자원의 수를 나타내며 세마포어 값이 0이면 자원이 없음을 의미합니다. <br/>P 연산은 세마포어 값을 1 감소시키며 값이 0보다 크면 프로세스가 실행됩니다. 값이 0이라면 프로세스는 대기합니다. 반면 V 연산은 세마포어 값을 1 증가시키는 연산으로, 만약 대기 중인 프로세스가 있다면 그 중 하나를 깨워 실행할 수 있도록 합니다.

  <br/> 
  
  <details>
    <summary>
      <strong>고전적인 동기화 문제인 독자-작가 문제를 해결하기 위해서는 이진 세마포어와 카운팅 세마포어 중 어떤 것을 사용하는게 효과적일까요?</strong>
    </summary>
    <br/>
    이진 세마포어를 이용해 해결할 수 있습니다. 첫번째로 현재 몇 명의 독자가 읽고 있는지를 추적하는 변수로 이 변수를 이진 세마포어를 통해 보호합니다. 여러 독자가 읽기위해 이 변수에 접근하다 잘못된 수정으로 인해 값을 제대로 나타내지 못할 수 있기 때문에 해당 변수를 보호하기 위한 이진 세마포어가 필요합니다. <br/>
    두번째로는 작가의 쓰기 작업 보호를 위해 글을 쓰는 공간을 위한 이진 세마포어가 필요합니다. 작가가 쓰는 동안에는 독자가 접근할 수 없게하고 작가가 쓰지 않고 있을 때는 여러 명의 독자가 해당 구역에 접근할 수 있도록 합니다.
  </details>
</details>

<br/>

<details>
  <summary><h3>3. 뮤텍스와 세마포어의 차이는 무엇인가요?</h3></summary>
  뮤텍스는 상호 배제를 위해 설계된 도구로 한 번에 하나만 접근할 수 있습니다. 반면 세마포어는 여러 프로세스가 자원에 접근할 수 있도록 허용하는 카운터 기반의 도구로, 이진 세마포어와 카운팅 세마포어가 있습니다.

  뮤텍스는 잠금을 획득한 프로세스만이 해제할 수 있으므로 락을 가지고 있는 소유권 개념이 있습니다. 그러나 세마포어는 다른 프로세스가 신호를 보내는 방식이지 잠금을 하는 락에 대한 소유권의 개념 자체가 없습니다. 

  <br/> 
  
  <details>
    <summary>
      <strong>바쁜 대기(busy waiting)은 왜 성능에 영향을 미치나요? 이를 방지하기 위한 방법은 무엇인가요?</strong>
    </summary>
    <br/>
    바쁜 대기 방식은 계속 해서 임계 구역에 접근할 수 있는지를 확인하기 때문에 CPU 자원을 계속 사용하며 확인하게 됩니다. 이는 CPU 자원을 낭비하기 때문에 성능에 영향을 미치게 됩니다. 이를 방지하기 위한 방법은 다음과 같습니다. 
      <ul>
        <li> 스핀 락 방식을 짧은 대기 시간이 있는 곳에서만 사용
        <li> 인터럽트 사용해서 프로세스가 대기해야하는 조건이 발생하게 되면 하드웨어 인터럽트가 해당 프로세스를 깨워서 CPU를 점유하지 않도록 설계 (I/O 완료와 같은 외부 이벤트에 의해 발생)
        <li> 슬립 락(sleep lock)을 사용해서 프로세스가 자원을 사용할 수 없다면, CPU를 사용하지 않고 슬립 상태로 들어가고 자원이 준비되면 다시 깨워지도록 설계 (자원에 대한 접근을 제어하고 대기 상태를 관리하기 위해 사용)
      </ul>
  </details>
  <br/>
  <details>
    <summary>
      <strong>이진 세마포어와 카운팅 세마포어의 차이는 무엇인가요?</strong>
    </summary>
    <br/>
    이진 세마포어는 값을 0과 1로만 가질 수 있기 때문에 임계 구역에 하나의 프로세스만 접근이 가능하지만, 카운팅 세마포어는 여러 개의 자원에 대해 다룰 수 있습니다.
  </details>

  <br/>
  <details>
    <summary>
      <strong>세마포어의 동작 방식에서 P, V 연산의 차이는 무엇인가요?</strong>
    </summary>
    <br/>
    P 연산은 자원을 요청하고 자원이 사용 가능하다면 임계 구역에 진입할 수 있게 합니다. 세마포어 값을 감소시키며 0보다 작은 값이라면 프로세스는 블록 상태로 있습니다. <br/>
    반면 V 연산은 자원 사용이 끝났음을 알리고 대기 중인 프로세스에게 자원을 사용할 수 있게 합니다. 세마포어 값을 증가시키며, 대기 중인 프로세스가 있다면 깨웁니다. 
  </details>
  <br/>
  <details>
    <summary>
      <strong>세마포어를 사용할 때 성능 저하가 발생할 수 있는 경우는 무엇인가요?</strong>
    </summary>
    <br/>
    대표적인 경우로는 높은 경쟁 상황입니다. 많은 프로세스가 동시에 같은 프로세스를 기다리게 되는 경우, 문맥 교환(context switching)이 빈번하게 발생하게 되며 시스템 성능이 저하됩니다.
    예를 들어 데이터베이스 연결 풀을 세마포어로 관리할 때 풀의 크기가 너무 작고 동시 요청이 많으면 프로세스들이 연결을 하기 위해 지속적으로 블록되고 깨어나는 과정을 반복하게 되고, 이는 CPU 자원을 낭비하고 전체 시스템 성능 저하를 일으키게 됩니다.
  </details>
</details>

<br/>

<details>
  <summary><h3>4. 생산자-소비자 문제란 무엇일까요?</h3></summary>
  생산자-소비자 문제는 병행 프로그래밍에서 발생하는 대표적 동기화 문제입니다. 생산자 프로세스가 데이터를 생성하여 버퍼에 넣고, 소비자 프로세스가 버퍼에서 데이터를 가져가는 상황을 다룹니다. 
  
  <br/> 
  
  <details>
    <summary>
      <strong>생산자-소비자 문제를 세마포어로 어떻게 해결할 수 있나요?</strong>
    </summary>
    <br/>
      생산자-소비자 문제를 세마포어로 해결하기 위한 방법은 다음과 같습니다.
      <br/>
      <ul>
        <li> 상호배제를 위한 이진 세마포어인 mutex(1)와 빈 버퍼 개수를 나타내는 empty(n), 찬 버퍼의 개수를 나타내는 full(0)을 정의한다. (괄호의 숫자는 처음 초기화될 때의 값이다.)
        <li> 생산자 프로세스는 빈 버퍼인지 empty를 확인하고 P(mutex) 연산으로 임계 영역에 진입한다. (mutex는 1이었다가 0이 된다.)
        <li> 위 작업을 진행한 생산자 프로세스는 버퍼에 데이터를 추가한다. 이때 mutex = 0이므로 아무도 임계 영역인 버퍼에 진입할 수 없다.
        <li> 데이터 추가가 완료되면 V(mutex), V(full) 연산을 통해 mutex는 1로, 버퍼에 쓴 만큼 full도 증가시킨다.
        <li> 소비자 프로세스는 P(full), P(mutex) 연산을 차례로 진행한다. 이때 버퍼가 차 있는지 확인하고 mutex도 1이라면 버퍼에 접근한다. (mutex = 1이라는 것은 생산자가 현재 쓰기 작업을 하지 않고 있으므로 접근이 가능하다는 의미다.)
        <li> 버퍼에 접근한 소비자는 버퍼에서 데이터를 제거한 후 V(mutex), V(empty) 연산을 통해 임계 영역을 탈출하고 빈 퍼버 개수를 증가시킨다.
      </ul>
  </details>
  <details>
    <summary>
      <strong>이때 버퍼를 원형 버퍼로 사용한다면 장단점이 있을까요?</strong>
    </summary>
    <br/>
      <ul>
        <li> 장점으로는 원형이기 때문에 메모리를 효율적으로 사용하고, 오버플로우 문제를 자연스럽게 해결할 수 있습니다. 원형이므로 그 공간만큼만 계속 사용하기 때문이다.
        <li> 단점으로는 원형 버퍼를 구현하는 것은 일반 버퍼보다는 구현이 복잡하고, 버퍼 크기가 고정되어 있기 때문에 유연성이 떨어진다.
      </ul>
  </details>
</details>

<br/>

<details>
  <summary><h3>5. Spin Lock에서 lock을 기다리는 프로세스는 어디에 위치하나요?</h3></summary>
  스핀 락을 기다리는 프로세스는 실행 상태를 계속 유지하며, CPU를 사용하게 됩니다. 이는 일반적인 세마포어와는 다른 동작 방식으로, 일반 세마포어에서는 프로세스가 블록되어 대기 큐로 이동하지만, 스핀 락에서는 대기 상태가 아닌 실행 상태를 유지하며 프로세스가 루프를 돌며 계속해서 락의 획득을 시도합니다.
</details>

<br/>

<details>
  <summary><h3>6. 식사하는 철학자의 실제 프로그래밍적 예시를 설명할 수 있을까요?</h3></summary>
  식사하는 철학자 문제는 데이터베이스 예시 문제로 연결해볼 수 있다. 만약 철학자 1, 2, 3이 있다면 각 철학자는 트랜잭션에서 철학자 1은 a, b 테이블, 철학자 2는 b, c 테이블, 철학자 3은 c, a 테이블에 접근해야한다고 가정한다. 그렇다면 서로 다른 철학자들이 서로의 테이블에 접근해야하기 때문에 교착 상태가 발생할 수 있다. 철학자 1은 a, 철학자 2는 b, 철학자 3은 c 테이블에 접근했지만, 다른 테이블에 접근하려하면 다른 철학자들이 모두 해당 테이블을 사용하고 있기 때문에 기다려야한다.

  <br/> 
  
  <details>
    <summary>
      <strong>어떻게 해결할 수 있을까요?</strong>
    </summary>
    <br/>
      <ul>
        <li> 타임아웃을 설정합니다. 각 철학자가 자원을 요청하면 특정 시간 안에 자원을 얻지 못하면 요청을 취소하고 다시 시도하도록 한다. 
        <li> 자원할당 그래프를 통해 현재 어떤 자원이 사용 중인지, 어떤 프로세스가 기다리는지 추적합니다. 새로운 요청으로 교착 상태가 발생한다면 해당 요청을 거부합니다. 
        <li> 다중 락을 사용합니다. 한 번에 모든 자원을 요청하는 방식으로, 중간에 자원을 해제하는 일이 없도록 합니다. 예를 들어 철학자 1이 테이블 a, b에 대한 요청을 동시에 하도록 처리합니다.
      </ul>
  </details>
</details>