계층별로 정리된 자료는 너무 많기도 하고 하향식접근 책이 각 계층별로 다루고있어서,, 개념적인건 간단하게 넘어가고 난해한 부분이나 궁금한 부분 위주로 정리했습니다. 자세한건 파트별로..

### 들어가기 전에 프로토콜이란?

통신 규약 → 어떻게 통신을 맺고 전송을 하겠다~ 미리 정해놓은거임. 프로토콜마다 지향하는거나 필요성이 달라서 만든사람이 그거에 맞게 했다고 보면 됨

예를 들면

**HTTP**

- 누구나 쉽게 이해하고 구현하길 원해서 텍스트 기반, 요청과 응답이라는 간단한 구조 지향
- 웹이 커질수록 새로운 기능이 필요할거라고 생각해서 추가하기 쉽게 설계

**FTP**

- 한 비트도 틀리지 않고 정확하게 전송해야해서 신뢰성이 중요했음
- 처음 나왔던 1970년대에는 네트워크가 매우 느리고 비싸서 최대한 효율적으로

![image](https://github.com/user-attachments/assets/fbe9a1ca-ae23-4ffb-866f-98bcb008fdb8)

각 계층이 암튼 이렇게 있고 레이어가 내려가면서 뭐가 점점 더 붙어서 전송된다. 먼가 붙여나가는 이유랑 역할이 있겠지? 실제 택배 보내는거랑은 좀 다르지만 택배 보내는거에 비유해서 설명해보자면

### 응용 계층

- 사용자가 직접 네트워크와 상호작용하는 계층
- HTTP, SMTP(메일), FTP(파일) 등의 프로토콜
- 정보 패킷을 **메시지**라고 부름
- **택배 보내는 물건이 응용 계층의 데이터**

### 표현 계층

- 서로 다른 시스템 간 데이터를 주고 받을 때 양쪽 모두가 이해할 수 있는 공통의 형식으로 변환
- 문자 인코딩, 이미지 압축 등등
- **택배를 전송하기 적합한 형태로 포장.**

### 세션 계층

- 응용 프로세스가 전체 통신을 관리하기 위한 방법 제공
  - 세션 수립과 유지
  - 동기화
  - 세션 복구
  - 대화 제어 : 전이중, 반이중, 단방향
  - 토큰 관리
- 데이터 교환의 경계와 동기화 제공 → 먼소리임?
  - 게임할 때 중요한 순간들 (레벨 시작, 체크포인트, 레벨 종료) 등이 데이터 교환의 경계점임
  - 세션 계층은 이런 지점들을 표시하고 여러 플레이어의 게임 진행을 맞춰줌
  - 정기적으로 **동기화 지점**을 만들고, 양쪽 모두 이 지점에 도착할 때까지 기다렸다가 준비되면 다음 단계로 진행
- **택배 접수 당담자가 받는 사람과의 통신 연결 설정(연락처 확인, 부재시 대응 등)**

### 전송 계층

- 클라이언트와 서버 간에 애플리케이션 계층 메시지를 전송
- TCP/UDP
- 흐름/혼잡 제어
- 정보 패킷을 **세그먼트(TCP), 데이터그램(UDP)** 라고 부름
- **택배를 더 잘 보내기 위해 작은 단위로 나눔**

### 네트워크 계층

- 한 호스트에서 다른 호스트로 **데이터그램** 라우팅
- 경로 설정 : 최적의 경로 설정
- 주소 지정 : 정확한 IP 주소 지정
- 트래픽 제어
- IP 프로토콜
- **택배에 주소 표기, 최적의 배송 경로 설정**

### 데이터링크 계층

- 신뢰성 있는 정보 전달 → 올바른 목적지로, 오류 검출 및 수정, 흐름 제어
- 이더넷, 와이파이 등
- 정보 패킷을 **프레임** 이라고 부름
- **더 안전하게 포장하여 파손 방지**

### 물리 계층

- 프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동
- 실제 전송 매체(광케이블, 무선 등)에 의존
- **택배기사 출발**

근데 사실 이후엔 실제 인터넷이 동작하는 방식에 가까운 TCP/IP 프로토콜 5계층 모델을 사용하게 됨

왜? → OSI 표현, 세션 계층이 응용 계층에 통합되었는데 응용 프로그램들이 실제로는 이 세 계층의 기능을 명확히 구분하지 않고 함께 처리함. 브라우저는 데이터 표현과 세션 관리를 자체적으로 처리

### 궁금한/난해한 점들

<details>
  <summary><strong>왜 이렇게 나눠놨을까?</strong></summary>

- 각 계층별로 자신의 역할에만 집중할 수 있음
- 독립적으로 동작하므로 어느 계층에서 문제가 생기거나 수정/업데이트 할 때 다른 계층에 영향을 미치지 않음
</details>
<details>
  <summary><strong>어떻게 동작하는걸까?</strong></summary>

처음에 공부할 땐 출발지에서 7→1 도착지에서 1→7 이런 순으로 간다고 이해했다. 근데 좀 지나니까 `네트워크 계층에서는 IP 프로토콜로 통신한다` 이런식으로 설명해서 뭐지..? 계층끼리 통신하는건가? 하면서 헷갈렸다.

결론적으로 말하자면 네트워크 계층에서도 네트워크 → 링크 → 물리 순서로 통신한다.
![image (1)](https://github.com/user-attachments/assets/bc03ba91-d80f-4856-ac4f-4487c07a46ec)

저런식으로 다 올라갈 필요 없이 필요한 만큼 올라가서 왔다갔다 하면서 통신한다.

</details>
<details>
  <summary><strong>브라우저 쿠키에 저장된 세션 ID? 쿠키, 토큰 이런건 세션 계층인가?</strong></summary>

결론적으로 말하자면 세션 ID랑 네트워크 모델의 세션 계층은 전혀 다른 개념이다.

실제로는 HTTP 프로토콜의 일부이기 때문에 응용 계층에서 처리된다. OSI 모델에서의 세션은 네트워크 연결의 설정, 유지, 종료를 관리하는거고 웹에서 말하는 세션은 사용자의 로그인 상태나 방문 기록같은 상태 정보를 의미한다.

</details>
<details>
  <summary><strong>죄다 신뢰성있는 통신이라는데 그냥 주소에 보내면 되는거 아닌가? 신뢰성 있다는게 뭘까?</strong></summary>

전송 계층에서 TCP는 신뢰성 있는 정보를 전달한다고 한다. 링크 계층에서도 신뢰성 있는 정보 전달을 한다고한다. 각 계층에서 말하는 `신뢰성` 의 의미와 처리 범위가 다르다.

- **세션 계층의 신뢰성**
  - 애플리케이션 관점의 신뢰성
  - 장시간 지속되는 대화(세션) 수준에서 데이터 교환의 신뢰성 보장
  - 대용량 파일이 전송 중 끊겼을 때 처음부터가 아닌 끊긴 지점부터 다시 전송하는 체크포인트
  - 통신 중인 두 애플리케이션의 동기화
  - 세션이 비정상적으로 종료되었을 때의 복구 기능
- **TCP의 신뢰성**
  - end-to-end. 즉 출발지 호스트에서 목적지 호스트까지의 전체 경로에 대한 신뢰성을 책임짐.
  - 순서 보장 : 데이터가 보낸 순서대로 도착하도록 보장
  - 데이터 무결성 : 체크섬을 통해 데이터가 손상되지 않았는지 확인한다
  - 손실 복구 : ACK, 타이머를 사용해 데이터가 손실되면 재전송
  - 흐름제어 : 수신측의 처리 속도를 고려하여 전송 속도 조절
  - 자세한건 자세한건 전송 계층 파트를 공부하자
- **링크 계층에서의 신뢰성**
  - hop-by-hop. 즉 직접 연결된 두 노드 사이의 신뢰성만 책임짐.
  - 물리적 오류 감지 : 비트 단위의 오류를 감지하고 수정
  - 프레임 단위의 전송 관리 : 프레임 시작과 끝을 구분하고, 프레임 단위로 오류 체크
  - 매체접근제어(MAC) : 여러 노드가 동시에 전송하려 할 때 충돌 방지
- 세션 계층의 신뢰성은 가구점에서 전체 이사 프로젝트를 관리하는것
- TCP의 신뢰성은 서울↔부산의 전체 배송 과정을 추적하고 분실되면 다시 보내고, 순서가 바뀌면 바로잡는 것
- 링크 계층의 신뢰성은 각 배송구간 (서울→대전, 대전→대구, 대구→부산)에서 택배 차량이 안전하게 물건을 운반하는 것
</details>
<details>
  <summary><strong>세션 계층의 토큰이 우리가 아는 access token, refresh token인가?</strong></summary>

`아니다.`

세션 계층의 토큰은 네트워크 상에서 통신하는 두 시스템 간의 `대화 순서`를 제어하기 위함이다. 회의할 때 손 들고 마이크를 들고 있는 사람만 발언할 수 있는 것 처럼 토큰을 가진 시스템만이 데이터를 전송할 수 있다. 이는 데이터 충돌을 방지하고 통신의 질서를 유지하는 것이 주요한 목적이다.

인증 토큰은 7계층 응용계층에서 사용되는 보안 인증 메커니즘임

</details>
<details>
  <summary><strong>전송 계층에서는 왜 / 어떻게 쪼갤까?</strong></summary>

-     - 네트워크 장비들은 한 번에 처리할 수 있는 데이터 크기에 제한이 있음 (MTU)
      - 작은 패킷들로 나누면 다른 데이터들도 그 사이사이에 전송될 수 있어서 네트워크 대역폭을 더 효율적으로 사용할 수 있음
      - 오류 발생시 작은 패킷 하나만 재전송하면 되므로 효율적임
      - 각 조각에는 고유한 식별자, 순서 정보등이 필요하고 헤더에 포함됨
      - TCP의 세그멘테이션
          - MSS(Maximum Segment Size)를 기준으로 데이터를 쪼갬
          - MSS = MTU - IP헤더 - TCP헤더
      - UDP
          - TCP와 마찬가지로 MTU를 고려해서 데이터를 쪼개지만 이 계층을 IP 계층에 위임
          - UDP는 단순히 데이터를 전달하기만 하고 단편화는 IP계층에서 일어남

      자세한건 전송 계층 파트를 공부하자

  </details>
  <details>
    <summary><strong>전송 계층에서는 어떻게 흐름/혼잡 제어를 할까?</strong></summary>

**흐름 제어**

- **슬라이딩 윈도우** 방식
- 수신자가 수신 버퍼의 크기를 송신자에게 알리고, 송신자가 그 윈도우 크기만큼 데이터 전송
- 수신자가 데이터를 처리하면 처리된 만큼 윈도우 이동 + 윈도우 크기는 상황에 따라 동적으로 조절

**혼잡 제어**

- **Slow Start**
  - 임계점까지 ACK를 받을 때마다 윈도우 크기 2배씩 증가
- **Congestion Avoidance**
  - Slow Start의 임계점 이후 혼잡 윈도우를 1MSS씩 선형적으로 증가
  - 패킷 손실 발생할 때까지 계속
- **Fast Retransmit**
  - 중복된 ACK 3번 받으면 패킷 손실로 간주
  - 해당 패킷을 즉시 재전송
  - 타임아웃을 기다리지 않아 효율적
- **Fast Recovery**
  - 패킷 손실 후 윈도우를 반으로 줄임
  - 선형적인 증가 단계로 즉시 진입

자세한건 전송 계층 파트를 공부하자

</details>
<details>
  <summary><strong>네트워크 계층에서는 어떻게 최적의 경로를 찾을까?</strong></summary>

- RIP : 가장 단순한 방식으로 목적지까지 거쳐야 하는 라우터의 개수만을 고려함
- OSPF : 더 정교한 방식으로 각 링크의 대역폭, 지연시간, 혼잡도 등을 고려함
- BGP : 실제 인터넷에서 사용되는 정책 기반 라우팅.
  - 특정 국가를 통과하지 않는 경로, 비용이 적게 드는 경로 등 여러가지 고려하여 결정
- 자세한건 네트워크 계층 파트의 라우팅 프로토콜을 공부하자
</details>
<details>
  <summary><strong>전송 계층 UDP의 데이터그램과 네트워크 계층의 데이터그램은 같은걸까?</strong></summary>

`아니다.`

**전송 계층(UDP)의 데이터그램**

- 전송 계층에서 사용되는 데이터 단위
- 포트 번호와 체크섬 같은 전송 계층의 추가 정보 포함
- **편지봉투 안에 들어있는 편지지 (받는 사람의 부서나 호수가 명시되어 건물에 도착한 후 정확한 수신자에게 전달되도록)**

**네트워크 계층(IP)의 데이터그램**

- 출발지 → 목적지 데이터를 전달하는 기본 단위인 IP 패킷을 의미함
- 라우팅을 위한 정보(출발지 IP, 도착지 IP)를 담고 있고 네트워크상에서 독립적으로 경로를 찾아감
- **주소가 적혀있는 편지 봉투**
</details>
<details>
  <summary><strong>데이터링크 계층에서는 어떻게 신뢰성 있는 정보 전달을 할까?</strong></summary>

발생할 수 있는 문제는 다음과 같다 :

- 비트 오류 : 전송 중에 비트가 뒤집할 수 있음
- 프레임 손실 : 전체 프레임이 사라짐
- 프레임 중복 : 같은 프레임이 여러 번 전송

이러한 문제들을 해결하기 위해 :

- **오류 감지**
  - 체크섬 : 데이터의 각 부분을 더한 후 그 합계를 데이터와 함께 전송. 수신자는 같은 계산 수행하여 일치하는지 확인
  - 순환 중복 검사 : 데이터를 특정 다항식으로 나누어 나머지를 구하고 그 나머지를 전송. 체크섬보다 계산이 좀 더 복잡하지만 연속된 비트 오류도 검출 가능하는 등 오류 검출 능력이 뛰어남.
- **프레임 구성**
  - 연속된 비트열을 의미 있는 단위로 구분하기 위해 프레임 사용
- **흐름 제어**
  - 수신자의 처리 능력을 고려하여 데이터의 전송 속도 조절
  - Stop and Wait
  - Sliding Window
- **오류 제어**
  - ARQ(Automatic Repeat Request) 기법을 사용하여 오류가 발견된 프레임 재전송
  - Go-Back-N :
    - 앞에서 오류가 발생하면 그 뒤를 다 다시 전송
  - Selective Repeat :
    - 해당 프레임만 재전송

**위의 계층들이 하는거랑 비슷한데?**

→ 실제로 네트워크 계층들 사이에는 비슷한 매커니즘이 많음. 다만 그 범위와 구현 방식이 좀 다름

</details>
<details>
  <summary><strong>계층간에는 어떻게 이동할까?</strong></summary>

응용 계층에서부터 물리 계층까지 이동하고, 물리 계층에서 유뮤선으로 보내는건 알겠는데 그럼 중간에 계층간에서는 어떻게 이동할까?

1. 응용 계층 : 이 부분만 개발자가 직접 구현한다.

   ```python
   import socket

   # 소켓 생성 (운영체제에 통신 요청)
   client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

   # 서버에 연결
   client_socket.connect(('example.com', 80))

   # 데이터 전송 (응용 계층에서 만든 데이터)
   client_socket.send('Hello'.encode())
   ```

2. 전송 계층 - 물리 계층 : 이 부분들은 운영체제가 제공한다. 운영체제의 네트워크 스택은 사용자 영역(User Space)과 커널 영역(Kernel Space)로 나뉘어진다. - 사용자 영역 : 응용 프로그램, 라이브러리 등. 웹 브라우저나 이메일 클라이언트 같은 프로그램이 여기서 동작함. 이 프로그램들은 소켓 API를 통해 커널의 네트워크 기능을 사용함 - 커널 영역 - 소켓 인터페이스 계층 : 사용자 프로그램과 커널 사이의 다리 역할을 함. 프로그램이 `connect()`, `send()` 같은 소켓 함수를 호출하면 이 계층이 그 요청을 받아서 처리함 - 프로토콜 계층 - TCP/UDP 계층 : 연결 관리, 흐름 제어, 오류 복구 - IP 계층 : 패킷의 라우팅을 담당. 라우팅 테이블 관리 - 네트워크 장치 인터페이스 : - 실제 네트워크 카드와 통신하는 드라이버 관리 - 네트워크 카드의 큐 관리 - 인터럽트 처리
</details>
<details>
  <summary><strong>브라우저에서 www.naver.com에 접속과정 계층별로?</strong></summary>

3. DNS 해석 단계
   - 도메인 네임을 IP주소로 변환하기 위해 운영체제가 DNS 서버와 통신하여 IP 주소를 얻음
   - 이 과정 자체도 네트워크 스택을 통해 이루어짐
4. 연결 시작 단계
   - 브라우저는 운영체제의 소켓 API 호출
   - 운영체제의 네트워크 스택 활성화
   - TCP 연결을 위한 준비 완료
5. TCP handshake
   - **클라이언트와 서버의 운영체제의 전송계층 끼리** 통신
6. HTTP 요청 단계 - 연결이 설정된 후 실제 HTTP 요청이 이루어짐
</details>
<details>
  <summary><strong>근데 HTTP 요청을 하면 먼저 멈추고 TCP handshake를 한다. 그럼 뭔가가 운영체제의 TCP 모듈로 전달되어야 할 것 같은데 그게 뭘까?</strong></summary>

HTTP 요청을 보내기 전에, 브라우저는 먼저 connect() 시스템 콜을 호출한다.

```jsx
async function sendHttpRequest() {
  // 1. 소켓 생성
  const socket = createSocket();

  // 2. 연결 시도 (이 때 TCP 핸드쉐이크가 시작됨)
  await socket.connect(serverAddress, port);

  // 3. 연결이 완료된 후에야 HTTP 요청을 보냄
  socket.send("GET / HTTP/1.1\r\n...");
}
```

</details>
