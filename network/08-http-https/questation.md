# Q

## Q1 X.509에 대해서 아시는 만큼 설명해주세요.

- X.509는 공개키 인증서(Public Key Certificate)의 표준 형식
- ITU-T(국제전기통신연합)에서 정의한 표준으로 PKI(Public Key Infrastructure)에서 사용
- 인증서에는 다음 정보가 포함됨:
  - 인증서 버전
  - 일련번호
  - 서명 알고리즘 식별자
  - 발행자(Issuer) 정보
  - 유효기간(시작일/만료일)
  - 주체(Subject) 정보
  - 주체의 공개키 정보
  - 인증서 확장 필드(Extensions)
  - 인증 기관(CA)의 디지털 서명
- 웹 보안(HTTPS), 이메일 보안(S/MIME), 코드 서명 등 다양한 보안 응용 프로그램에서 사용
- 현재 X.509 v3가 가장 널리 사용됨

## Q2 CA란 무엇이고 CA의 계층 구조에 대해서 아시는 만큼 설명해주세요.

- CA(Certificate Authority)는 디지털 인증서를 발행하는 신뢰할 수 있는 기관
- 주요 역할:

  - 인증서 신청자의 신원 확인
  - 디지털 인증서 발행
  - 인증서 상태 관리(유효, 폐기 등)
  - 인증서 저장소 유지 관리

- CA 계층 구조:

  1. 루트 CA(Root CA):

     - 계층 구조의 최상위에 위치
     - 자체 서명된(self-signed) 인증서를 가짐
     - 오프라인 상태로 보관되는 경우가 많음(보안 강화)
     - 중간 CA의 인증서에 서명

  2. 중간 CA(Intermediate CA):

     - 루트 CA와 최종 사용자 인증서 사이에 위치
     - 루트 CA에 의해 인증됨
     - 실제 최종 사용자 인증서 발급 담당
     - 여러 계층으로 구성될 수 있음

  3. 최종 엔티티 인증서(End-entity Certificate):
     - 최종 사용자나 서비스에 발급되는 인증서
     - 웹 서버, 클라이언트, 이메일 등에 사용

- 이러한 계층 구조는 '신뢰 체인(Chain of Trust)'을 형성
- 계층 구조의 장점:
  - 보안 강화(루트 CA 보호)
  - 인증서 관리 용이성
  - 특정 중간 CA 손상 시 영향 범위 제한

## Q3 CA 인증 방식에 대해서 아시는 만큼 설명해주세요.

- CA 인증 방식은 크게 다음과 같은 절차로 이루어짐:

1. 인증서 요청 생성:

   - 신청자가 개인키와 공개키 쌍을 생성
   - CSR(Certificate Signing Request) 생성
   - CSR에는 공개키와 조직 정보가 포함됨

2. 신원 확인(Validation):

   - DV(Domain Validation): 도메인 소유권만 확인(이메일, DNS 레코드, HTTP 확인 등)
   - OV(Organization Validation): 조직의 실제 존재 및 도메인 소유권 확인
   - EV(Extended Validation): 가장 엄격한 검증, 법적 실체, 물리적 존재, 운영 확인 등

3. 인증서 발급:

   - CA가 CSR을 검증하고 공개키에 디지털 서명
   - 유효기간, 용도, 발급자 정보 등을 포함한 X.509 인증서 생성
   - 인증서를 신청자에게 전달

4. 인증서 설치 및 사용:

   - 신청자가 서버나 애플리케이션에 인증서 설치
   - 클라이언트는 CA 인증서를 통해 서버 인증서 검증

5. 인증서 갱신/폐기:
   - 인증서 만료 전 갱신 절차
   - 필요시 인증서 폐기(CRL, OCSP 등 이용)

- 추가 인증 방식:
  - Let's Encrypt: ACME 프로토콜을 이용한 자동화된 무료 인증서 발급
  - 자체 서명 인증서(Self-signed): CA 없이 자체적으로 서명(테스트 환경 등에서 사용)
  - 다중 도메인 인증서(SAN): 여러 도메인을 하나의 인증서로 인증
  - 와일드카드 인증서: 하위 도메인을 모두 포함하는 인증서(\*.example.com)

## Q4 X.509에서 PKI 란 무엇인가요 ?

- PKI(Public Key Infrastructure)는 공개키 암호화를 지원하는 종합적인 보안 인프라 시스템
- X.509는 PKI에서 사용되는 인증서 표준 형식

- PKI의 주요 구성 요소:

  1. CA(Certificate Authority): 인증서 발급 및 관리
  2. RA(Registration Authority): 사용자 등록 및 신원 확인
  3. 인증서 저장소(Certificate Repository): 발급된 인증서 저장 및 조회
  4. 인증서 폐기 목록(CRL) 또는 OCSP: 폐기된 인증서 정보 제공
  5. 키 복구 시스템: 필요시 키 복구를 위한 시스템
  6. 보안 정책 및 절차: PKI 운영을 위한 정책 및 절차

- PKI의 주요 기능:

  - 디지털 서명: 메시지 인증 및 부인 방지
  - 암호화: 기밀성 보장
  - 인증: 통신 당사자의 신원 확인
  - 무결성: 데이터 변조 방지
  - 부인 방지(Non-repudiation): 송신자가 메시지 전송 사실을 부인할 수 없음

- PKI의 신뢰 모델:

  - 계층적 신뢰 모델: 루트 CA를 중심으로 한 계층 구조
  - 웹 오브 트러스트(Web of Trust): PGP 등에서 사용하는 분산형 신뢰 모델
  - 브리지 CA 모델: 여러 PKI 도메인 간 상호 인증

- PKI는 X.509 인증서를 통해 공개키의 신뢰성과 유효성을 보장하여 안전한 통신 및 전자 거래를 가능하게 함

## Q5 TLS 1.2과 1.3에 차이에 대해서 아시는 만큼 설명해주세요

- TLS 1.3(2018년 표준화)은 TLS 1.2(2008년 표준화)에 비해 다음과 같은 주요 개선사항이 있음:

1. 핸드셰이크 성능 개선:

   - TLS 1.2: 최소 2-RTT(왕복 시간) 필요
   - TLS 1.3: 1-RTT로 축소, 재연결 시 0-RTT 옵션 제공
   - 클라이언트가 첫 메시지에서 바로 키 교환 매개변수 제시

2. 보안 강화:

   - 취약한 암호화 알고리즘 제거:
     - RC4, DES, 3DES, MD5, SHA-1, RSA 키 교환 등 제거
   - 정방향 비밀성(Forward Secrecy) 의무화:
     - DHE, ECDHE와 같은 임시 키 교환 방식만 허용

3. 암호 스위트 간소화:

   - TLS 1.2: 다양한 암호 스위트 조합 (수십 가지)
   - TLS 1.3: AEAD(Authenticated Encryption with Associated Data) 암호만 지원
     - AES-GCM, AES-CCM, ChaCha20-Poly1305 등 5개로 축소

4. 핸드셰이크 암호화:

   - TLS 1.2: 초기 핸드셰이크 메시지는 평문 전송
   - TLS 1.3: 서버 인증서를 포함한 핸드셰이크 메시지 대부분 암호화

5. 디지털 서명 알고리즘 개선:

   - RSA-PSS, EdDSA 등 더 안전한 서명 알고리즘 도입
   - SHA-256 이상의 해시 함수만 사용

6. 세션 재개 메커니즘 개선:

   - TLS 1.2: 세션 ID와 세션 티켓 사용
   - TLS 1.3: PSK(Pre-Shared Key) 기반 통합 메커니즘 도입

7. 중간자 공격 방어 개선:

   - 서버 매개변수 협상 과정 보호
   - 확장 필드 암호화로 민감한 정보 보호

8. 0-RTT(Zero Round Trip Time) 재연결:
   - 이전에 연결했던 서버에 재연결 시 추가 왕복 없이 즉시 데이터 전송 가능
   - 단, 재생 공격 위험이 있어 주의 필요

## Q6 TLS 핸드셰이크 과정에서 클라이언트와 서버가 상호 인증하는 방식 및 과정에 대해 아는 만큼 설명해주세요.

### TLS 상호 인증(Mutual Authentication) 과정

- 일반적인 TLS는 서버만 인증하지만, 상호 인증에서는 클라이언트도 인증서를 제공

#### TLS 1.2 상호 인증 핸드셰이크 과정:

1. 클라이언트 Hello:

   - 클라이언트가 지원하는 TLS 버전, 암호 스위트, 랜덤 데이터 전송

2. 서버 Hello:

   - 서버가 선택한 TLS 버전, 암호 스위트, 랜덤 데이터 응답

3. 서버 인증서:
   - 서버가 자신의 인증서(또는 인증서 체인) 전송
4. 서버 키 교환(선택적):

   - DHE/ECDHE 사용 시 필요한 매개변수 전송

5. 클라이언트 인증서 요청:

   - 서버가 클라이언트에게 인증서 요청
   - 허용 가능한 인증서 유형 및 CA 목록 포함

6. 서버 Hello 완료:

   - 서버의 초기 메시지 완료 신호

7. 클라이언트 인증서:

   - 클라이언트가 자신의 인증서(또는 인증서 체인) 전송
   - 인증서가 없는 경우 빈 인증서 메시지 전송 가능

8. 클라이언트 키 교환:

   - 프리마스터 시크릿(pre-master secret) 생성에 필요한 정보 전송

9. 클라이언트 인증서 검증:

   - 클라이언트가 자신의 개인키로 이전 핸드셰이크 메시지 해시에 서명
   - 이를 통해 인증서에 해당하는 개인키 소유 증명

10. 변경 암호 명세(Change Cipher Spec):

    - 이후 모든 메시지는 협상된 암호화 매개변수로 암호화됨을 알림

11. 완료(Finished):
    - 이제까지의 모든 핸드셰이크 메시지 해시를 암호화하여 전송
    - 양쪽이 동일한 보안 매개변수를 가지고 있는지 확인

#### TLS 1.3 상호 인증 핸드셰이크 과정 (간소화됨):

1. 클라이언트 Hello:

   - 지원하는 암호 스위트, 키 공유 매개변수(예: ECDHE) 포함
   - 이전 세션 재개를 위한 PSK 식별자(있는 경우)

2. 서버 Hello + 암호화된 확장 + 인증서 + 인증서 검증 + Finished:

   - 서버가 선택한 암호 스위트와 키 교환 매개변수
   - 임시 키를 이용해 나머지 핸드셰이크 메시지 암호화
   - 서버 인증서 및 서명

3. 클라이언트 인증서 요청(암호화됨):

   - 서버가 클라이언트에게 인증서 요청

4. 클라이언트 인증서 + 인증서 검증 + Finished:
   - 클라이언트 인증서 전송
   - 인증서에 대한 서명 검증 데이터
   - 핸드셰이크 완료 메시지

### 상호 인증 검증 방식:

- 서버 인증:

  - 클라이언트가 서버 인증서의 유효성 검증
  - 인증서가 신뢰할 수 있는 CA에 의해 서명되었는지 확인
  - 인증서의 도메인명이 접속한 서버와 일치하는지 확인
  - 인증서 만료 여부, 폐기 여부 확인

- 클라이언트 인증:

  - 서버가 클라이언트 인증서의 유효성 검증
  - 인증서가 신뢰할 수 있는 CA 또는 지정된 CA에 의해 서명되었는지 확인
  - 인증서 만료 여부, 폐기 여부 확인
  - 클라이언트가 인증서에 해당하는 개인키를 소유하고 있는지 확인(서명 검증)

- 추가 검증:
  - 인증서 확장 필드(Extended Key Usage 등) 확인
  - 인증서 정책 확인
  - OCSP 또는 CRL을 통한 실시간 폐기 상태 확인

## Q7 Perfect Forward Secrecy(PFS)가 무엇이며, 이를 통해 보안을 강화하는 방법에 대해 설명해주세요.

- Perfect Forward Secrecy(PFS) 또는 Forward Secrecy(FS)는 암호화 통신에서 장기 개인키가 손상되어도 과거 세션 키를 복구할 수 없도록 하는 보안 속성

### PFS의 핵심 개념:

- 매 세션마다 독립적인 임시(ephemeral) 키 사용
- 이전 통신 내용은 이후에 키가 노출되어도 안전함
- 장기 개인키는 인증에만 사용, 세션 키 생성에는 임시 키 사용

### PFS가 없는 표준 RSA 키 교환의 문제점:

1. 클라이언트가 랜덤 프리마스터 시크릿 생성
2. 서버의 공개키로 암호화하여 전송
3. 서버가 개인키로 복호화하여 세션 키 도출
4. 문제점: 서버의 개인키가 추후 노출되면 기록된 모든 과거 세션 복호화 가능

### PFS 구현 방법:

1. Diffie-Hellman Ephemeral(DHE) 또는 Elliptic Curve DHE(ECDHE) 사용:

   - 매 세션마다 새로운 DH 매개변수 생성
   - 통신 종료 후 임시 키 폐기
   - ECDHE는 DHE보다 작은 키 크기로 동등한 보안 제공(성능 우수)

2. TLS에서의 PFS 구현:

   - TLS 1.2: DHE 또는 ECDHE 암호 스위트 사용
     - 예: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
   - TLS 1.3: 모든 핸드셰이크가 PFS 의무화 (DHE/ECDHE만 지원)

3. 추가 보안 강화 방법:
   - 키 교환 매개변수 강화: DHE에 2048비트 이상, ECDHE에 P-256 이상의 곡선 사용
   - 세션 키 재협상 주기 설정: 많은 데이터 교환 시 주기적 키 갱신
   - 임시 키 생성을 위한 강력한 난수 생성기(CSPRNG) 사용
   - 서버 설정에서 비PFS 암호 스위트 비활성화

### PFS의 이점:

- 패시브 감청 공격에 대한 장기적 보호
- 서버 개인키 손상 시 피해 범위 제한
- 법적 요청에 의한 데이터 복호화 어려움 증가
- 양자 컴퓨팅 위협에 대한 일부 완화 효과

### PFS의 단점:

- 약간의 성능 오버헤드 발생 (특히 DHE, ECDHE는 상대적으로 효율적)
- 구현 복잡성 증가
- 일부 오래된 클라이언트와의 호환성 문제 가능성

## Q8 인증서 폐기(Revocation)와 갱신 절차에 대해 아는 만큼 설명해주세요.

### 인증서 폐기(Certificate Revocation)

#### 폐기 사유:

- 개인키 손상/도난
- 회사 또는 도메인 소유권 변경
- 인증서 정보의 변경 필요
- CA 정책 위반
- 서버 또는 서비스 중단
- 인증서 오발급

#### 폐기 메커니즘:

1. 인증서 폐기 목록(CRL - Certificate Revocation List):

   - CA가 주기적으로 발행하는 폐기된 인증서 목록
   - 인증서 일련번호와 폐기 날짜/시간, 폐기 사유 포함
   - 구조:
     - 발행자 정보(Issuer)
     - 마지막 업데이트/다음 업데이트 시간
     - 폐기된 인증서 목록(일련번호, 폐기일, 사유 등)
   - 문제점:
     - 크기가 커질 수 있음(확장성 문제)
     - 주기적 업데이트로 인한 시간차
     - 대역폭 및 클라이언트 부하 증가

2. OCSP(Online Certificate Status Protocol):

   - 실시간 인증서 상태 확인 프로토콜
   - 특정 인증서의 상태만 조회(CRL보다 효율적)
   - 응답: good, revoked, unknown
   - 문제점:
     - 응답자(OCSP 서버) 가용성에 의존
     - 추가 네트워크 요청으로 인한 지연
     - 프라이버시 문제(CA가 사용자 접속 정보 파악 가능)

3. OCSP Stapling:

   - 서버가 CA로부터 OCSP 응답을 미리 받아 TLS 핸드셰이크에 포함
   - 장점:
     - 클라이언트가 OCSP 서버에 직접 접속할 필요 없음
     - 성능 향상 및 프라이버시 보호
     - CA 서버 부하 감소
   - TLS 확장 기능(status_request)으로 구현

4. CRL Distribution Points:

   - 인증서 내 CRL 위치 정보 포함
   - 분산된 CRL 서버로 부하 분산 가능

5. CT(Certificate Transparency):
   - 발급된 모든 인증서를 공개 로그에 기록
   - 부적절하게 발급된 인증서 감지에 도움
   - 직접적인 폐기 메커니즘은 아니지만 보완 역할

#### 폐기 절차:

1. 인증서 소유자가 CA에 폐기 요청
2. CA는 신원 확인 후 인증서 폐기
3. 폐기 정보 CRL/OCSP에 반영
4. 필요시 새 인증서 발급

### 인증서 갱신(Certificate Renewal)

#### 갱신 시기:

- 인증서 만료일 접근 시(일반적으로 30-90일 전)
- 키 강화가 필요한 경우
- 인증서 정보 변경 필요 시

#### 갱신 유형:

1. 표준 갱신(Standard Renewal):

   - 동일한 키 쌍으로 새 인증서 발급
   - 절차가 간단하지만 보안 측면에서 권장되지 않음

2. 키 갱신(Rekey):
   - 새로운 키 쌍 생성 후 새 인증서 발급
   - 보안 강화 측면에서 권장됨
   - 개인키 노출 위험 감소

#### 갱신 절차:

1. CA로부터 갱신 알림 수신
2. 새 CSR(Certificate Signing Request) 생성(키 갱신 시)
3. CA에 인증서 갱신 요청
4. 도메인 검증 및/또는 조직 검증 절차
5. 새 인증서 발급 및 서버 설치
6. 이전 인증서 백업 및 보관

#### 자동 갱신:

- Let's Encrypt와 같은 CA는 ACME 프로토콜로 자동 갱신 지원
- 서버 소프트웨어(Certbot 등)로 인증서 자동 갱신 설정
- 대기업용 인증서 관리 솔루션으로 대량 인증서 자동 갱신 관리

#### 갱신 모범 사례:

- 만료일 최소 30일 전 갱신 시작
- 새 키 쌍 사용(키 갱신)
- 자동화된 갱신 프로세스 구축
- 갱신 실패 시 알림 시스템 구축
- 갱신 후 서비스 정상 작동 확인
- 이전 인증서 안전하게 보관

## Q9 Certificate Pinning의 개념과 적용 시 고려해야 할 점에 대해 설명해주세요.

### Certificate Pinning 개념

- Certificate Pinning(인증서 고정)은 클라이언트 애플리케이션이 특정 서버와 통신할 때 미리 정의된 인증서나 공개키만 신뢰하도록 하는 보안 기법
- 일반적인 TLS/SSL 인증 과정에서는 CA 체인만 검증하지만, 인증서 고정은 실제 서버 인증서나 공개키까지 검증
- CA 시스템이 손상되거나 신뢰할 수 없게 되어도 보안 유지 가능
- 다양한 유형:
  - 공개키 고정(Public Key Pinning): 서버의 공개키 해시를 저장
  - 인증서 고정(Certificate Pinning): 전체 인증서를 저장
  - CA 고정(CA Pinning): 특정 CA나 중간 인증서만 신뢰

### 적용 방법

1. 모바일 애플리케이션:

   - 앱 내부에 인증서/공개키 정보 하드코딩
   - 네트워크 요청 시 서버 인증서와 비교

2. 웹 애플리케이션:

   - HTTP Public Key Pinning(HPKP): 웹 서버가 HTTP 헤더를 통해 클라이언트에 키 정보 전달
   - 참고: HPKP는 보안 위험으로 인해 대부분의 브라우저에서 지원 중단

3. 구현 방식:
   - 앱 개발 시 인증서/키 정보 내장
   - 인증서 체인의 여러 수준에서 고정 가능(루트 CA, 중간 CA, 최종 인증서)
   - HTTP 요청 라이브러리 확장하여 추가 검증 구현

### 적용 시 고려사항

1. 유연성과 가용성:

   - 인증서 갱신 시 앱 업데이트 필요(하드코딩 시)
   - 백업 키/인증서 설정(여러 개 고정)으로 유연성 확보
   - 예기치 않은 인증서 변경 시 서비스 접근 불가 위험

2. 구현 복잡성:

   - 개발 및 유지보수 부담 증가
   - 오류 처리 및 복구 메커니즘 필요
   - 다양한 플랫폼에서의 일관된 구현 도전

3. 긴급 대응 계획:

   - 개인키 유출 시 신속한 대응 방안
   - 고정된 인증서/키 업데이트 메커니즘 설계
   - 사용자 경험 고려한 실패 처리 방안

4. 보안과 사용성 균형:
   - 너무 엄격한 고정은 가용성 저하
   - 너무 느슨한 고정은 보안 효과 감소
   - 적절한 수준의 고정 정책 수립

## Q10 HTTP1.x 과 HTTP2의 차이가 무엇인가요 ?

- HTTP/2는 2015년에 표준화된 프로토콜로 HTTP/1.x에 비해 다음과 같은 주요 차이점을 가짐:

1. 바이너리 프로토콜:

- HTTP/1.x: 텍스트 기반 프로토콜
- HTTP/2: 바이너리 프레임 기반 프로토콜(파싱 효율성 향상)

2. 멀티플렉싱(Multiplexing):

- HTTP/1.x: 요청/응답이 순차적으로 처리됨(HOL 차단 문제)
- HTTP/2: 하나의 TCP 연결로 여러 요청/응답을 병렬 처리

3. 헤더 압축:

- HTTP/1.x: 헤더 반복 전송으로 오버헤드 발생
- HTTP/2: HPACK 알고리즘으로 헤더 압축(대역폭 사용 효율화)

4. 스트림 우선순위:

- HTTP/1.x: 우선순위 지정 불가
- HTTP/2: 요청에 가중치 부여 가능(리소스 할당 최적화)

5. 서버 푸시:

- HTTP/1.x: 클라이언트 요청에만 응답 가능
- HTTP/2: 클라이언트 요청 없이도 서버가 리소스 푸시 가능

6. 연결 관리:

- HTTP/1.x: 여러 연결 사용(도메인 샤딩 기법 필요)
- HTTP/2: 단일 TCP 연결 사용(연결 오버헤드 감소)

7. 흐름 제어:

- HTTP/1.x: TCP 수준에서만 흐름 제어
- HTTP/2: 스트림 별 흐름 제어 가능

## Q11 HTTP2의 멀티플렉싱 기법은 항상 빠른가요 ?

- HTTP/2의 멀티플렉싱이 항상 빠른 것은 아님

### 멀티플렉싱이 유리한 경우:

- 다수의 작은 리소스를 가진 웹페이지
- 높은 지연시간(latency)을 가진 네트워크 환경
- 여러 도메인에서 리소스를 가져오는 경우

### 성능이 제한될 수 있는 상황:

1. TCP 혼잡 제어 영향:

- 단일 TCP 연결에 의존하므로 패킷 손실 발생 시 모든 스트림이 영향 받음
- HTTP/1.x의 다중 연결은 일부 연결에 문제가 생겨도 다른 연결은 영향 적음

2. TCP HOL(Head-of-Line) 차단:

- HTTP/2는 애플리케이션 레벨에서 HOL 차단 문제를 해결했으나
- 전송 계층(TCP)에서의 HOL 차단 문제는 여전히 존재

3. 네트워크 환경에 따른 차이:

- 낮은 대역폭, 낮은 지연 환경에서는 이점이 적을 수 있음
- 높은 패킷 손실률을 가진 네트워크에서는 성능 저하 가능성

4. 리소스 특성에 따른 영향:

- 대용량 단일 리소스만 필요한 경우 멀티플렉싱의 이점 적음
- 스트림 우선순위 설정이 부적절할 경우 중요 리소스 지연 가능

5. 서버 구현 차이:

- 서버의 HTTP/2 구현 품질에 따라 성능 차이 발생
- 병렬 처리 최적화가 잘 되지 않은 서버는 이점 감소

6. 클라이언트 측 제한:

- 브라우저별 동시 스트림 수 제한 정책 차이
- 일부 환경에서는 스트림 처리 자원 부족으로 제한 발생

## Q12 HTTP2의 알려진 보안 문제가 무엇일까요 ?

HTTP/2는 보안을 향상시키기 위한 여러 메커니즘을 도입했지만, 다음과 같은 보안 문제가 알려져 있음:

1. 구현 복잡성 관련 취약점:

- 복잡한 프로토콜 구현으로 인한 버그 발생 가능성
- 프레임 파싱, 상태 관리 등에서 메모리 오류 발생 가능성

2. 압축 관련 공격:

- HPACK 헤더 압축 관련 정보 유출 가능성
- CRIME, BREACH와 유사한 압축 측면 채널 공격 가능성

3. 서버 푸시 남용:

- 서버 푸시 기능 악용으로 DDoS 공격 가능성
- 불필요한 리소스 푸시로 인한 대역폭 낭비

4. 기존 TLS 취약점 상속:

- HTTP/2가 TLS 위에서 실행될 경우 TLS 자체 취약점 영향
- 오래된 TLS 버전 사용 시 보안 위험

5. TCP 단일 연결 의존성:

- 단일 TCP 연결 사용으로 연결 장애 시 전체 서비스 영향
- TCP 기반의 HOL 차단으로 인한 서비스 거부 공격 가능성

6. 우선순위 및 의존성 악용:

- 스트림 우선순위 체계 악용으로 서비스 품질 저하 가능
- 복잡한 의존성 트리 생성으로 서버 자원 고갈 가능

7. 헤더 블록 크기 제한 우회:

- 헤더 블록 크기 제한을 우회하는 공격
- 대량의 헤더 필드 전송으로 메모리 부하 유발

8. SETTINGS 프레임 악용:

- SETTINGS 매개변수 조작으로 성능 저하 유발 가능
- 반복적인 설정 변경으로 서버 부하 증가

9. 프로토콜 식별 및 다운그레이드:

- ALPN 협상 과정에서의 다운그레이드 공격 가능성
- HTTP/2 지원 탐지를 통한 표적 공격

10. 중간자(Middlebox) 간섭:

- 일부 네트워크 장비의 HTTP/2 트래픽 오해석
- 방화벽, 프록시 등의 부적절한 처리로 보안 약화

## Q13 HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

GET 요청에 Body를 포함할 수 있지만 아직 지양되는 이유:

1. HTTP 스펙 관련 문제:

- HTTP/1.1 스펙은 GET 요청의 Body 처리에 대해 명확하게 정의하지 않음
- RFC 7231: "요청 Body의 의미론적 해석은 메서드에 따라 다르며, GET에서는 의미가 없음"

2. 캐싱 호환성 문제:

- 대부분의 캐시 시스템은 URL만을 캐시 키로 사용
- GET 요청의 Body는 캐시 키에 포함되지 않아 일관성 문제 발생
- 동일 URL에 다른 Body로 요청 시 잘못된 캐싱 결과 가능

3. 프록시/미들웨어 호환성:

- 많은 프록시와 네트워크 장비가 GET 요청의 Body를 예상치 않거나 무시
- 일부 구형 프록시는 GET 요청의 Body를 제거하기도 함

4. URL 길이 제한 해결책으로 적합하지 않음:

- GET 요청의 Body로 URL 길이 제한을 우회하려는 시도가 있으나
- POST나 다른 적절한 메서드 사용이 더 명확한 의미론적 접근

5. 의미론적 일관성:

- HTTP 메서드는 의미론적 목적을 가짐
- GET은 리소스 조회, POST는 리소스 생성/수정
- GET with Body는 이러한 의미론적 구분을 모호하게 함

6. 브라우저 구현 차이:

- 일부 브라우저 API는 GET 요청에 Body 포함을 제한
- 웹 폼에서 GET 메서드 사용 시 Body 대신 쿼리 파라미터로 변환

7. 보안 문제:

- GET 요청은 URL이 로그에 기록됨
- Body 데이터는 URL에 없어 로깅되지 않아 감사 추적 어려움
- 일관되지 않은 보안 정책 발생 가능성

8. RESTful 원칙과 불일치:

- RESTful API 설계 원칙에서 GET은 안전하고 멱등성을 가져야 함
- Body를 포함한 GET은 이러한 원칙을 위반할 가능성

## Q14 HTTP3에선 QUIC을 사용하는데 QUIC에 대해서 아시는 만큼 설명해주세요.

QUIC(Quick UDP Internet Connections)은 Google이 개발하고 IETF에서 표준화한 새로운 전송 프로토콜:

### QUIC의 주요 특징:

1. UDP 기반 프로토콜:

- TCP 대신 UDP 위에 구현
- 운영체제 커널 스택의 제한에서 벗어남
- 애플리케이션 레벨에서 구현으로 빠른 혁신과 배포 가능

2. 통합된 TLS 보안:

- TLS 1.3이 프로토콜에 내장
- 핸드셰이크 과정 간소화
- 초기 핸드셰이크 시 암호화와 전송 설정 동시 진행

3. 연결 설정 지연 감소:

- 0-RTT 연결 설정 지원
- 이전에 방문한 서버에 대해 즉시 데이터 전송 가능
- 재연결 시 연결 매개변수 저장 및 재사용

4. 향상된 혼잡 제어:

- 더 나은 혼잡 제어 알고리즘 적용 가능
- 패킷 손실 감지와 복구 개선
- BBR(Bottleneck Bandwidth and Round-trip) 같은 현대적 알고리즘 지원

5. 연결 이주(Connection Migration):

- 네트워크 전환(예: Wi-Fi에서 셀룰러로) 시에도 연결 유지
- 연결 식별자(Connection ID)를 통한 IP 주소 변경에도 연결 지속
- 모바일 기기에 특히 유용

6. 스트림 멀티플렉싱:

- 단일 연결 내에서 독립적인 다중 스트림
- 스트림 단위의 흐름 제어
- 스트림 간 HOL(Head-of-Line) 차단 문제 해결

7. 패킷 손실 처리 개선:

- 개별 패킷에 고유한 패킷 번호 부여
- 재전송된 패킷도 새로운 패킷 번호 받음
- 모호한 ACK 문제 해결

8. 향상된 오류 정정:

- 선택적 ACK으로 특정 패킷만 재전송
- 패킷 수준 오류 감지 및 복구

### QUIC의 구성 요소:

1. 전송 계층:

- 연결 설정 및 관리
- 패킷 암호화 및 인증
- 혼잡 제어

2. 스트림 계층:

- 양방향 스트림 생성 및 관리
- 스트림별 흐름 제어
- 스트림 우선순위 지정

3. 보안 계층:

- TLS 1.3 기반 암호화
- 키 협상 및 인증
- 트래픽 보호

### QUIC의 장점:

- 지연 시간 감소(특히 모바일 네트워크)
- 향상된 연결 신뢰성
- 네트워크 전환에 강인함
- 단일 스트림 문제가 전체 연결에 영향 미치지 않음
- 프로토콜 진화 용이성

### QUIC의 도전 과제:

- 일부 네트워크 장비/방화벽의 UDP 트래픽 차단/제한
- 디버깅 도구 부족
- CPU 사용량 증가(암호화 비용)
- 표준화 과정에서의 변화

## Q15 HTTP2의 서버 푸시(Server Push) 기능이 어떻게 동작하며, 실제로 성능에 미치는 영향에 대해 아는 만큼 설명해주세요.

### HTTP/2 서버 푸시 동작 방식

1. 기본 개념:

- 서버가 클라이언트의 명시적 요청 없이도 리소스를 미리 전송할 수 있는 기능
- 예: HTML 페이지 요청 시 CSS, JavaScript 파일도 함께 푸시

2. 동작 매커니즘:

- 클라이언트가 초기 리소스(보통 HTML) 요청
- 서버는 응답과 함께 PUSH_PROMISE 프레임 전송
- PUSH_PROMISE에는 푸시할 리소스의 경로 및 헤더 정보 포함
- 클라이언트는 PUSH_PROMISE를 통해 푸시될 리소스 인지
- 서버는 별도 스트림으로 푸시 리소스 전송

3. 푸시 스트림 관리:

- 각 푸시 리소스는 별도의 스트림으로 전송
- 클라이언트는 RST_STREAM 프레임으로 푸시 거부 가능
- 클라이언트의 SETTINGS_ENABLE_PUSH 설정으로 푸시 기능 제어 가능

4. 캐싱 처리:

- 푸시된 리소스도 일반 리소스와 동일하게 캐싱
- If-Modified-Since 같은 조건부 요청 헤더 지원

### 성능에 미치는 영향

#### 긍정적 영향:

1. 왕복 지연 시간(RTT) 감소:

- 클라이언트의 추가 요청 없이 리소스 전달
- 특히 높은 지연 시간 네트워크에서 효과적

2. 리소스 우선순위 최적화:

- 서버가 중요 리소스 먼저 푸시 가능
- 크리티컬 렌더링 패스 최적화에 도움

3. 리소스 발견 효율화:

- HTML 파싱 전에 필요 리소스 전달 가능
- 브라우저의 점진적 파싱과 시너지 효과

#### 부정적 영향:

1. 대역폭 낭비 가능성:

- 이미 캐시된 리소스 푸시 시 낭비
- 사용자가 실제 필요하지 않은 리소스 전송

2. 캐시 상태 파악 어려움:

- 서버는 클라이언트 캐시 상태 알 수 없음
- 불필요한 푸시 발생 가능

3. 우선순위 경쟁:

- 푸시 리소스가 중요 요청 리소스와 대역폭 경쟁
- 잘못 구현 시 성능 저하 가능

4. 리소스 낭비:

- 클라이언트가 페이지 이탈 시에도 푸시 계속
- 서버 측 리소스 사용 증가

### 실제 성능 영향 사례

1. 혼합된 성과:

- Chrome 데이터: 많은 경우 서버 푸시가 기대한 성능 향상 못 미침
- HTTP Archive: 실제 사용 사이트 약 1.8% 미만

2. 효과적인 사용 사례:

- 작은 크기의 중요 CSS/JS 푸시(특히 초기 렌더링 필수 리소스)
- 모바일 네트워크 등 고지연 환경
- 사용자 행동 예측 가능한 앱

3. 비효율적인 사용 사례:

- 대용량 리소스 푸시
- 조건부 로드되는 리소스 푸시
- 캐시 가능성 높은 리소스 무분별 푸시

### 서버 푸시 모범 사례

1. 선택적 사용:

- 중요 렌더링 경로 리소스에 집중
- 작은 크기 리소스 우선 푸시

2. 캐시 인식:

- 쿠키/로컬스토리지로 클라이언트 상태 추적
- 조건부 푸시 구현

3. 모니터링 및 측정:

- 실제 성능 영향 측정
- A/B 테스트로 효과 검증

4. HTTP/3으로 전환 고려:

- HTTP/3에서는 서버 푸시 대신 다른 최적화 기법 사용

## Q16 HTTP/3와 기존 HTTP/2 간의 성능 차이 및 적용 시 고려해야 할 요소에 대해 아는 만큼 설명해주세요

### HTTP/3와 HTTP/2 간 성능 차이

#### 연결 설정 성능:

- HTTP/2: TCP + TLS 핸드셰이크 필요 (최소 2-3 RTT)
- HTTP/3: QUIC 사용으로 첫 연결 시 1-RTT, 재방문 시 0-RTT
- 이점: 초기 페이지 로드 시간 감소, 특히 모바일 네트워크에서 효과적

#### 패킷 손실 상황에서의 성능:

- HTTP/2: TCP의 HOL(Head-of-Line) 차단으로 하나의 패킷 손실이 모든 스트림에 영향
- HTTP/3: 독립적인 스트림 처리로 일부 패킷 손실이 다른 스트림에 영향 없음
- 이점: 손실률 높은 네트워크(모바일 등)에서 성능 향상

#### 네트워크 전환 처리:

- HTTP/2: IP 주소 변경 시 연결 재설정 필요
- HTTP/3: 연결 마이그레이션 지원으로 네트워크 전환 시에도 연결 유지
- 이점: 모바일 기기에서 Wi-Fi ↔ 셀룰러 전환 시 원활한 경험

#### 혼잡 제어:

- HTTP/2: TCP 혼잡 제어에 의존
- HTTP/3: QUIC 자체 혼잡 제어 알고리즘 사용(BBR 등)
- 이점: 현대적 네트워크 환경에 최적화된 성능

#### 실제 측정된 성능 차이:

- 초기 페이지 로드: HTTP/3는 HTTP/2 대비 약 5-10% 빠름
- 패킷 손실 시: 2-3% 손실 환경에서 HTTP/3는 HTTP/2 대비 30-40% 성능 우위
- 모바일 네트워크: HTTP/3는 불안정한 모바일 연결에서 일관된 성능 개선

### 적용 시 고려해야 할 요소

#### 인프라 및 배포 고려사항:

1. 서버 지원:

- 주요 웹 서버(Nginx, Apache) 및 CDN의 HTTP/3 지원 여부
- QUIC 구현에 따른 CPU 사용량 증가 대비

2. 네트워크 장비 호환성:

- 방화벽, 로드 밸런서 등의 UDP/QUIC 지원
- 일부 기업 네트워크/미들박스가 UDP 443 차단 가능성

3. 폴백(Fallback) 메커니즘:

- HTTP/3 실패 시 HTTP/2로 원활한 전환 구성
- Alt-Svc 헤더 활용한 프로토콜 협상

#### 클라이언트 지원:

1. 브라우저 지원:

- 주요 브라우저(Chrome, Firefox, Safari, Edge)의 HTTP/3 지원 상태
- 클라이언트 구형 버전 사용자 비율 파악

2. API 클라이언트:

- 다양한 프로그래밍 언어/라이브러리의 HTTP/3 지원
- 자체 개발 클라이언트 업데이트 필요성

#### 모니터링 및 디버깅:

1. 도구 지원:

- HTTP/3 트래픽 모니터링 도구 제한적
- 기존 TCP 기반 도구로는 분석 어려움

2. 로깅 및 측정:

- HTTP/3 특화된 메트릭 수집 방법
- 성능 비교를 위한 A/B 테스트 설계

#### 리소스 최적화:

1. 서버 푸시 대안:

- HTTP/3는 서버 푸시 지원 제한적
- 103 Early Hints, Preload 헤더 등 대안 고려

2. 리소스 우선순위:

- HTTP/3의 새로운 우선순위 체계 활용
- 크리티컬 리소스 최적화 방안

#### 보안 고려사항:

1. TLS 구현:

- QUIC은 TLS 1.3 필수
- 레거시 TLS 버전 지원 중단 영향 평가

2. 인증서 관리:

- HTTP/3용 별도 인증서 불필요
- 기존 인증서로 HTTP/2, HTTP/3 동시 지원

#### 점진적 도입 전략:

1. 트래픽 비율 조정:

- 초기에는 일부 트래픽만 HTTP/3로 라우팅
- 모니터링 결과에 따라 비율 조정

2. 사용자 세그먼트별 도입:

- 모바일 사용자에게 우선 적용(더 큰 이점)
- 지역별, 네트워크 품질별 차등 적용

3. 성능 측정:

- 실제 사용자 메트릭(RUM) 활용
- 프로토콜별 성능 비교 대시보드 구축

## Q17 QUIC 프로토콜의 재전송 및 패킷 손실 복구 메커니즘에 대해 설명해주세요.

### QUIC의 패킷 손실 감지 및 재전송 메커니즘

#### 패킷 번호 처리:

1. 단조 증가 패킷 번호:

- 모든 패킷에 고유한 패킷 번호 할당
- 패킷 번호는 암호화되어 네트워크 공격자가 보지 못함
- 재전송된 패킷도 새로운 패킷 번호 받음(TCP와 차이점)

2. 패킷 번호 공간:

- 초기, 핸드셰이크, 애플리케이션 데이터 등 별도 패킷 번호 공간
- 각 공간마다 독립적인 패킷 번호 시퀀스 관리

#### 패킷 손실 감지:

1. 타임아웃 기반 감지:

- Probe Timeout(PTO): 패킷 전송 후 ACK 대기 시간
- PTO는 RTT 측정값과 편차를 기반으로 동적 계산
- 현대적인 타이머 기반 복구 메커니즘

2. 패킷 번호 간격 기반 감지:

- 수신된 ACK으로 빠진 패킷 번호 확인
- 3개 이상의 패킷이 손실된 패킷보다 더 큰 패킷 번호로 확인되면 손실로 간주
- RACK(Recent ACKnowledgment) 기반 알고리즘 적용

3. 확인응답(ACK) 메커니즘:

- 선택적 확인응답(SACK) 내장
- ACK 프레임에 복수의 ACK 범위 포함 가능
- ACK 지연(Delayed ACK) 타이머로 효율적인 ACK 생성

#### 패킷 재전송 및 복구:

1. 패킷 데이터 중심 접근:

- '패킷 재전송' 개념 대신 '데이터 재전송' 접근
- 손실된 패킷의 페이로드를 새 패킷 번호로 재전송

2. 스트림 레벨 복구:

- 스트림 데이터 단위로 재전송
- 손실된 특정 스트림 데이터만 선택적 재전송
- 스트림별 독립적 흐름 제어로 HOL 차단 방지

3. 암묵적 ACK:

- 특정 패킷 번호 이상의 ACK은 이전 모든 패킷 수신 의미
- ACK 프레임의 효율적인 압축 가능

4. 프로빙 패킷:

- 패킷 손실 감지 시 프로빙(probe) 패킷 전송
- 네트워크 연결 상태 확인 및 새로운 RTT 측정 촉진
- 새로운 데이터가 없는 경우 PING 또는 PADDING 프레임 사용

#### 혼잡 제어 통합:

1. 기본 혼잡 제어 알고리즘:

- TCP Reno/CUBIC과 유사한 기본 알고리즘
- 손실 기반 혼잡 감지 및 회피
- 느린 시작(Slow Start)과 혼잡 회피(Congestion Avoidance) 구현

2. BBR 지원:

- 구글의 BBR(Bottleneck Bandwidth and RTT) 알고리즘 구현 가능
- 대역폭과 지연 시간 측정 기반 모델 사용
- 패킷 손실에 덜 민감한 현대적 접근법

3. 혼잡 제어 신호:

- 패킷 손실, ECN(Explicit Congestion Notification) 지원
- 패킷 손실은 혼잡 신호로 해석

4. 혼잡 윈도우 관리:

- 각 연결별 혼잡 윈도우 유지
- 패킷 재정렬에 더 강인한 관리 기법 적용

#### 고급 손실 복구 기능:

1. 전방 오류 수정(Forward Error Correction):

- 일부 QUIC 구현에서 FEC 지원
- 추가 패리티 패킷으로 패킷 손실 복구
- 고지연/고손실 환경에서 유용

2. 다중 경로 전송:

- 멀티홈 환경에서 여러 네트워크 경로 활용 가능
- 경로별 패킷 손실 특성에 맞춘 전송 전략

### QUIC의 재전송 메커니즘이 TCP와 다른 점

1. 재전송 모호성 해결:

- TCP: 동일한 시퀀스 번호 재사용으로 재전송 모호성 발생
- QUIC: 항상 새로운 패킷 번호 사용으로 모호성 제거

2. HOL 차단 제거:

- TCP: 패킷 손실 시 모든 후속 데이터 전달 차단
- QUIC: 스트림별 독립적 전달로 한 스트림의 패킷 손실이 다른 스트림에 영향 없음

3. 정확한 RTT 측정:

- TCP: 재전송된 패킷에 대한 정확한 RTT 측정 어려움
- QUIC: 모든 패킷이 고유 번호로 정확한 RTT 측정 가능

4. 패킷 번호 암호화:

- TCP: 시퀀스 번호가 평문으로 네트워크에 노출
- QUIC: 패킷 번호가 암호화되어 네트워크 관찰자에게 보이지 않음

## Q18 프록시 서버 환경에서 TLS 및 QUIC의 동작 방식에 대해 아는 만큼 설명해주세요.

### 프록시 환경에서의 TLS 동작 방식

#### 투명 프록시(Transparent Proxy)와 TLS:

1. 패스스루(Pass-through) 모드:

- 프록시가 암호화된 TLS 트래픽을 그대로 전달
- 내용 검사 불가, 목적지 IP/포트 기반 라우팅만 가능
- 클라이언트-서버 간 E2E(End-to-End) 암호화 보존

2. TLS 인터셉션(중간자 방식):

- 프록시가 클라이언트와 서버 사이에서 두 개의 TLS 연결 생성
- 클라이언트-프록시 간 TLS, 프록시-서버 간 TLS
- 요구사항: 클라이언트 신뢰 저장소에 프록시 CA 인증서 설치
- 주로 기업 환경에서 콘텐츠 필터링, 보안 검사에 사용

3. SNI(Server Name Indication) 기반 라우팅:

- TLS 핸드셰이크의 SNI 확장 필드 검사
- 암호화되지 않은 ClientHello 메시지에서 호스트명 추출
- TLS 1.3에서 ESNI(Encrypted SNI)로 이 방식 제한

#### 명시적 프록시(Explicit Proxy)와 TLS:

1. HTTP CONNECT 메서드:

- 클라이언트가 프록시에 터널 생성 요청
- 프록시는 목적지 서버로 TCP 연결 생성
- 이후 클라이언트-서버 간 직접 TLS 핸드셰이크
- 프록시는 암호화된 내용 확인 불가

2. 프록싱 인증:

- 프록시 인증 헤더(Proxy-Authorization)
- HTTPS의 경우 CONNECT 메서드 후 TLS 터널 수립

### 프록시 환경에서의 QUIC 동작 방식

#### QUIC과 프록시의 호환성 문제:

1. UDP 기반 프로토콜의 도전:

- 대부분의 기존 프록시는 TCP 기반 설계
- HTTP CONNECT는 TCP 연결용으로 설계됨
- UDP 터널링을 위한 표준화된 방법 부족

2. 방화벽/미들박스 처리:

- 많은 기업 네트워크에서 UDP 443 필터링
- QUIC 패킷 특성 변경 시 연결 끊김
- 패킷 헤더 수정 시 QUIC의 무결성 검사 실패

#### QUIC 지원을 위한 프록시 솔루션:

1. HTTP/3 프록싱 표준:

- "Proxying HTTP/3" 초안 표준 작업 중
- CONNECT-UDP 메서드 제안
- 명시적 UDP 데이터그램 터널링

2. Alt-Svc 헤더 활용:

- 서버가 HTTP/2 응답에 Alt-Svc 헤더 포함
- 클라이언트에게 HTTP/3 지원 알림
- 클라이언트가 직접 QUIC 연결 시도

3. UDP 터널링 기법:

- HTTP/2 CONNECT를 통한 UDP 터널링
- WebTransport 프로토콜 활용
- UDP 패킷을 DTLS로 캡슐화

#### 프록시 유형별 QUIC 동작:

1. 투명 프록시:

- QUIC의 연결 ID로 클라이언트 IP 변경에도 연결 유지
- 대부분의 패킷이 암호화되어 DPI(Deep Packet Inspection) 제한
- 초기 핸드셰이크만 제한적 검사 가능

2. 명시적 프록시:

- HTTP/3용 CONNECT-UDP 메서드 구현 필요
- 클라이언트는 프록시 주소 명시적 구성
- TCP 폴백 메커니즘 필요

3. 리버스 프록시:

- 백엔드 서버와 QUIC 또는 TCP+TLS 사용 가능
- QUIC 연결 종료 후 내부적으로 라우팅
- CDN 등에서 유용

### 프록시 환경에서 TLS 및 QUIC 구현 시 고려사항

1. 성능 고려사항:

- TLS 인터셉션 시 추가 지연 발생
- QUIC 패킷 처리를 위한 프록시 최적화 필요
- 패킷 검사 깊이와 성능 간 균형

2. 보안 고려사항:

- TLS 인터셉션은 E2E 보안 모델 손상
- 프록시 CA 인증서 보호 중요
- QUIC의 암호화로 보안 검사 어려움

3. 호환성 고려사항:

- QUIC 폴백 메커니즘 구현
- 다양한 클라이언트/서버 버전 지원
- 레거시 시스템과의 통합

## Q19 QUIC 알고리즘의 핸드셰이크 과정에 대해서 아시는 만큼 설명해주세요.

### QUIC 핸드셰이크 과정

#### 일반적인 핸드셰이크 흐름(1-RTT):

1. 초기 단계:

- 클라이언트가 Initial 패킷 전송
- Version Negotiation(필요한 경우)
- CRYPTO 프레임에 TLS ClientHello 메시지 포함
- 초기 전송 매개변수 포함
- 초기 소스 연결 ID(SCID) 및 목적지 연결 ID(DCID) 설정

2. 서버 응답:

- 서버가 Initial 패킷으로 응답
- CRYPTO 프레임에 TLS ServerHello 메시지 포함
- 합의된 암호 스위트 및 키 공유 파라미터
- 서버 전송 매개변수 포함
- 서버가 생성한 연결 ID 제공

3. 키 교환 완료:

- 양측이 Initial 비밀(initial secret) 도출
- 초기 키 생성 및 패킷 암호화 시작
- TLS 1.3 핸드셰이크 통합
- Handshake 패킷으로 전환

4. 핸드셰이크 완료:

- 클라이언트가 Handshake 패킷으로 인증 데이터 전송
- 서버가 Handshake 완료 신호 전송
- 양측이 애플리케이션 데이터 전송 시작(1-RTT)
- HANDSHAKE_DONE 프레임으로 성공 확인

#### 0-RTT 핸드셰이크(재연결):

1. 이전 연결 정보 저장:

- 클라이언트가 이전 세션 티켓 및 전송 매개변수 저장
- 서버가 클라이언트별 세션 상태 저장

2. 0-RTT 시작:

- 클라이언트가 Initial 패킷과 함께 0-RTT 패킷 즉시 전송
- 저장된 키 자료로 0-RTT 키 도출
- 이전 연결 ID 및 매개변수 재사용
- 애플리케이션 데이터 즉시 전송(대기 없음)

3. 서버 처리:

- 서버가 세션 티켓 검증
- 0-RTT 키 도출 및 데이터 복호화
- 리플레이 공격 방지 검사
- 0-RTT 데이터 수락 또는 거부 결정

4. 정규 핸드셰이크 완료:

- 1-RTT 핸드셰이크 병행 진행
- 1-RTT 키 설정 완료 시 0-RTT에서 전환
- 핸드셰이크 완료 후 양방향 데이터 흐름

#### 핸드셰이크 구성 요소:

1. 버전 협상(Version Negotiation):

- 클라이언트가 지원하는 버전 나열
- 서버가 지원하는 버전 중 선택
- 합의 실패 시 Version Negotiation 패킷으로 알림

2. 전송 매개변수 교환:

- 최대 패킷 크기
- 초기 흐름 제어 창
- idle 타임아웃 값
- 연결 이주(migration) 선호도
- 스트림 제한 및 설정

3. TLS 1.3 통합:

- QUIC의 CRYPTO 프레임 내 TLS 메시지 캡슐화
- TLS 1.3만 지원(이전 버전 금지)
- 키 도출 및 인증 처리를 TLS에 위임

4. 연결 ID 관리:

- 초기 연결 및 이후 연결을 위한 ID 교환
- 여러 연결 ID 제공으로 연결 이주 지원
- 프라이버시를 위한 연결 ID 교체 메커니즘

#### 핸드셰이크 보안 특성:

1. 전송 층 보안:

- 대부분의 패킷 필드가 암호화됨
- 패킷 번호도 암호화로 보호
- 패킷 헤더 보호(Header Protection) 적용

2. 핸드셰이크 인증:

- 서버와 선택적 클라이언트 인증
- 중간자 공격 방지
- 리플레이 공격 방지 메커니즘

3. 키 업데이트:

- 핸드셰이크 이후 주기적 키 업데이트 지원
- KEY_UPDATE 프레임으로 새 키 자료 전파
- 장기 연결의 보안 강화

### TCP+TLS와 QUIC 핸드셰이크 비교

1. 왕복 시간(RTT) 감소:

- TCP+TLS 1.3: 최소 2-RTT(TCP + TLS)
- QUIC: 최초 연결 1-RTT, 재연결 0-RTT

2. 병렬 처리:

- TCP+TLS: 연결 설정과 TLS 핸드셰이크 순차 진행
- QUIC: 전송 및 암호화 핸드셰이크 통합 처리

3. 헤드 오브 라인(HOL) 차단:

- TCP+TLS: 핸드셰이크 패킷 손실 시 전체 지연
- QUIC: 패킷 손실 복구 메커니즘으로 영향 최소화

# HTTP 보안 질문

## Q21 Content Security Policy(CSP)의 역할과 적용 방법에 대해 아는 만큼 설명해주세요.

- CSP는 웹 애플리케이션에서 발생할 수 있는 XSS 공격을 방어하기 위한 추가 보안 계층
- 웹 페이지가 로드할 수 있는 리소스의 출처를 제한하여 공격 벡터를 감소시킴
- 신뢰할 수 있는 콘텐츠 소스를 명시적으로 정의하여 악성 코드 실행 방지
- 주요 기능:
- 인라인 스크립트 및 스타일 실행 제한
- eval() 및 유사 기능 사용 제한
- 미디어, 폰트, 프레임 등 다양한 리소스 유형별 제어
- 폼 제출 대상 제한
- 정책 위반 보고 메커니즘 제공

- 적용 방법:
- HTTP 헤더로 전송: Content-Security-Policy
- HTML 메타 태그로 정의: <meta http-equiv="Content-Security-Policy">
- 주요 지시문: default-src, script-src, style-src, img-src, connect-src 등
- 소스 값으로 'self', 'none', 도메인, https:// 등 지정

- 단계적 적용 전략:
- 보고 모드(Report-Only)로 시작하여 영향 분석
- 기본 정책(default-src 'self')으로 시작
- 필요한 예외 점진적 추가
- 인라인 스크립트에 nonce 또는 해시 적용
- 위반 보고서 분석 및 정책 최적화

- 고려사항:
- 서드파티 통합 영향
- 레거시 코드 호환성
- 정책 유지보수 부담
- 사용자 경험 영향 최소화

## Q22 Cross-Origin Resource Sharing(CORS)의 개념과 관련 보안 이슈에 대해 설명해주세요.

- CORS는 다른 출처(Origin)의 리소스에 웹 애플리케이션이 접근할 수 있도록 하는 메커니즘
- 출처(Origin)는 프로토콜, 도메인, 포트의 조합으로 정의됨
- 브라우저의 Same-Origin Policy를 안전하게 완화하기 위한 표준

- CORS 요청 유형:
- 단순 요청: 특정 조건 충족 시 사전 요청 없이 진행
- 사전 요청(Preflight): OPTIONS 메서드로 서버 허용 여부 확인
- 인증 포함 요청: 쿠키, 인증 정보 포함 시 특별 처리

- 주요 CORS 헤더:
- 요청: Origin, Access-Control-Request-Method, Access-Control-Request-Headers
- 응답: Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers 등

- CORS 관련 보안 이슈:
- 지나치게 관대한 CORS 정책(와일드카드 사용)
- 잘못된 출처 검증(부분 문자열 매칭 등)
- 동적 CORS 헤더 생성 취약점
- 내부 네트워크 스캐닝 가능성
- CSRF 공격과의 관계
- JSONP 사용으로 인한 취약점

- 보안 권장 사항:
- 최소 권한 원칙 적용(필요한 출처만 명시적 허용)
- 와일드카드(\*) 사용 최소화
- 인증 요청 시 특별한 주의(특정 출처만 허용)
- 출처 문자열 정확한 비교 검증
- CSRF 대응책 별도 구현

## Q23 HTTP 헤더 보안을 강화하는 방법(예: HSTS, X-XSS-Protection 등)에 대해 아는 만큼 설명해주세요.

- HTTP 헤더는 웹 애플리케이션 보안을 강화하는 중요한 메커니즘
- 주요 보안 헤더:

1. HTTP Strict Transport Security (HSTS):

- 브라우저가 항상 HTTPS로만 사이트에 접속하도록 강제
- SSL 스트리핑 공격 방지
- max-age 지시어로 정책 유지 기간 설정
- includeSubDomains로 하위 도메인에도 적용
- preload 목록 등록으로 최초 접속부터 보호

2. X-Content-Type-Options:

- 브라우저의 MIME 타입 스니핑 방지
- 'nosniff' 값으로 선언된 Content-Type 엄격 적용
- 콘텐츠 해석 방식 강제로 보안 향상

3. X-Frame-Options:

- 클릭재킹(Clickjacking) 공격 방지
- 페이지가 프레임 내에서 렌더링되는 것을 제어
- DENY, SAMEORIGIN, ALLOW-FROM 값으로 제어

4. X-XSS-Protection:

- 브라우저 내장 XSS 필터 활성화
- 레거시 헤더이며 CSP로 대체 추세
- 1; mode=block으로 공격 감지 시 페이지 로드 차단

5. Content-Security-Policy:

- XSS 및 데이터 주입 공격 방어
- 리소스 로드 출처 제한
- 인라인 스크립트 실행 제어

6. Referrer-Policy:

- HTTP 리퍼러 정보 전송 범위 제어
- 민감한 URL 정보의 노출 방지
- same-origin, no-referrer-when-downgrade 등 옵션

7. Feature-Policy/Permissions-Policy:

- 브라우저 기능 사용 제한
- 마이크, 카메라, 위치 등 민감한 기능 접근 제어
- 잠재적 악용 가능성 감소

8. Clear-Site-Data:

- 사용자 브라우저에서 사이트 데이터 삭제
- 로그아웃 시 캐시, 쿠키, 스토리지 클리어
- 인증 정보 잔존으로 인한 위험 감소

9. Public-Key-Pins (HPKP):

- 인증서 핀닝 구현
- 위조된 인증서를 통한 공격 방지
- 설정 오류 시 접근 문제 발생으로 사용 주의

- 보안 헤더 적용 고려사항:
- 헤더 간 충돌 가능성 검토
- 점진적 적용 및 모니터링
- 레거시 브라우저 호환성 확인
- 보안 헤더 스캐너 활용

- 효과적인 구현 방법:
- 웹 서버 설정(Apache, Nginx 등)
- 애플리케이션 코드 수준 설정
- 보안 헤더 관리 미들웨어 활용
- 지속적인 보안 헤더 모니터링 및 업데이트

## Q24 HTTP 프로토콜의 특징에 대해 설명해주세요.

- HTTP(HyperText Transfer Protocol)는 웹상에서 클라이언트와 서버 간 통신을 위한 프로토콜

- 주요 특징:

1.  비연결성(Connectionless):

    - 요청-응답 후 연결 종료
    - Keep-Alive로 연결 재사용 가능
    - 서버 자원 효율적 사용

2.  무상태(Stateless):

    - 각 요청은 독립적으로 처리
    - 이전 요청과의 상태 정보 유지하지 않음
    - 쿠키, 세션으로 상태 관리 구현

3.  요청-응답 기반:

    - 클라이언트가 요청 전송
    - 서버가 요청 처리 후 응답
    - 단방향 통신 모델

4.  텍스트 기반:

    - HTTP/1.x는 사람이 읽을 수 있는 텍스트 형식
    - 헤더와 본문 구분
    - HTTP/2부터 바이너리 형식 도입

5.  메서드 기반 작업:

    - GET, POST, PUT, DELETE 등 다양한 메서드
    - 리소스에 대한 의도 표현
    - RESTful API의 기반

6.  상태 코드:

    - 응답 상태를 숫자로 표현(200, 404, 500 등)
    - 클라이언트에게 처리 결과 전달
    - 5개 클래스로 구분(1xx, 2xx, 3xx, 4xx, 5xx)

7.  확장성:

    - 헤더를 통한 메타데이터 전달
    - 커스텀 헤더 정의 가능
    - 새로운 기능 확장 용이

8.  미디어 타입 지원:
    - Content-Type으로 다양한 데이터 형식 지원
    - MIME 타입 활용
    - 멀티파트 메시지 지원

- HTTP 버전별 특징:
- HTTP/0.9: 단순 GET 요청만 지원
- HTTP/1.0: 헤더 도입, 메서드 확장, 상태 코드 도입
- HTTP/1.1: 연결 재사용, 청크 전송, 캐싱 개선
- HTTP/2: 멀티플렉싱, 헤더 압축, 서버 푸시
- HTTP/3: QUIC 기반, UDP 사용, 연결 지연 감소

## Q25 HTTP와 HTTPS의 차이를 설명해주세요.

- HTTP와 HTTPS의 주요 차이점:

1. 보안:

- HTTP: 암호화 없는 평문 통신
- HTTPS: TLS/SSL로 암호화된 통신
- HTTPS는 도청, 변조, 위조로부터 데이터 보호

2. 포트:

- HTTP: 기본 포트 80
- HTTPS: 기본 포트 443
- 방화벽 정책에서 다르게 취급

3. URL 스킴:

- HTTP: "http://" 사용
- HTTPS: "https://" 사용
- 브라우저가 구분하여 처리

4. 인증서:

- HTTP: 서버 인증 메커니즘 없음
- HTTPS: SSL/TLS 인증서 사용
- 사용자에게 사이트 신원 보증

5. 성능:

- HTTP: 암호화 부담 없어 이론적으로 더 빠름
- HTTPS: 암호화/복호화 과정으로 약간의 오버헤드
- 최신 구현에서는 성능 차이 미미

6. SEO 영향:

- 구글 등 검색 엔진이 HTTPS 사이트 선호
- HTTPS는 보안 신호로 검색 순위에 긍정적 영향
- HTTP 사이트는 "안전하지 않음" 경고 표시

7. 기능 지원:

- 프로그레시브 웹 앱(PWA) 등 최신 웹 기능은 HTTPS 필수
- 서비스 워커, 지오로케이션 API 등 보안 기능 HTTPS 요구
- HTTP/2 및 HTTP/3는 실질적으로 HTTPS 필수

8. 데이터 무결성:

- HTTP: 전송 중 데이터 변조 감지 불가
- HTTPS: 데이터 무결성 검증 제공
- HTTPS는 중간자 공격 방지

9. 신뢰성:

- HTTP: 통신 당사자 신원 보증 없음
- HTTPS: 서버 신원 보증(클라이언트 인증도 가능)
- 사용자 신뢰도 향상

10. 캐싱:

- HTTP: 중간 프록시에서 쉽게 캐싱
- HTTPS: 엔드-투-엔드 암호화로 중간 캐싱 제한
- HTTPS 캐싱은 특정 헤더 설정 필요

## Q26 HTTP는 80이고 HTTPS 443 포트를 쓰는데 이걸 나눠서 사용하는 이유와 합쳐서 사용할 수 없는지 설명해주세요.

- HTTP와 HTTPS 포트를 나누어 사용하는 이유:

1. 프로토콜 구분:

- 서로 다른 프로토콜로 통신 방식이 다름
- HTTP는 평문, HTTPS는 TLS/SSL 암호화 레이어 추가
- 서버가 다른 방식으로 처리해야 함

2. 호환성 및 표준화:

- 인터넷 표준으로 확립된 구분
- IANA(Internet Assigned Numbers Authority)가 지정한 공식 포트
- 네트워크 장비, 방화벽 등의 기본 설정과 호환

3. 방화벽 정책:

- 기업 및 네트워크 방화벽에서 다르게 취급
- HTTPS(443)는 암호화 통신으로 허용정책 다름
- 보안상 HTTP(80)만 차단하는 경우도 존재

4. 독립적 서비스 운영:

- 동일 서버에서 HTTP와 HTTPS 서비스 분리 가능
- 리다이렉션, 마이그레이션 등 단계적 전환 지원
- 서비스별 다른 보안 정책 적용 가능

5. 역사적 배경:

- HTTP가 먼저 개발되고 80포트 할당
- 이후 보안 요구로 HTTPS 개발 시 새 포트(443) 할당
- 기존 HTTP 서비스 호환성 유지 필요

- 같은 포트에서 HTTP와 HTTPS를 함께 사용할 수 없는 기술적 이유:

1. 프로토콜 핸드셰이크 차이:

- 클라이언트-서버 통신 시작 방법이 근본적으로 다름
- HTTP: 바로 HTTP 요청 전송
- HTTPS: TLS 핸드셰이크 선행 후 암호화된 HTTP 요청

2. 서버 구성 충돌:

- 웹 서버가 특정 포트의 연결을 처리할 때 한 가지 프로토콜로 해석
- 동일 포트에서 암호화/비암호화 동시 처리 불가
- 초기 바이트 시퀀스로 어떤 프로토콜인지 결정 어려움

3. TLS 동작 방식:

- TLS는 TCP 연결 직후 시작되어야 함
- 같은 포트에서 일부는 TLS 시작, 일부는 바로 HTTP 요청 구분 불가
- TLS와 비TLS 트래픽 혼합 처리 메커니즘 없음

- 대안적 접근 방법:

1. 포트 리다이렉션:

- HTTP(80) 요청을 HTTPS(443)로 자동 리다이렉트
- 301/302 리다이렉트 응답으로 구현
- 현재 가장 일반적인 방식

2. HSTS(HTTP Strict Transport Security):

- 브라우저가 항상 HTTPS로만 접속하도록 강제
- 최초 HTTPS 접속 후 설정됨
- preload 목록으로 최초 접속부터 HTTPS 강제 가능

3. 애플리케이션 게이트웨이:

- 리버스 프록시가 HTTP/HTTPS 트래픽 처리 후 내부로 전달
- 보안 정책 일원화
- 내부적으로는 단일 프로토콜 사용 가능

4. Alt-Svc 헤더:

- HTTP/2, HTTP/3에서 대체 서비스 알림
- 다른 프로토콜/포트로 전환 유도
- 클라이언트 지원 필요
